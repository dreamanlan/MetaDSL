#pragma once

#include "UObject/StrongObjectPtr.h"
#include "Serialization/ArchiveCountMem.h"
#include "ProfilingDebugging/ResourceSize.h"
#include "BraceScript.h"
#include <iomanip>
#include <sstream>
#include <queue>
#include <unordered_map>
#include <memory>
#include <utility>
#include <type_traits>
#include <typeinfo>

namespace BraceScriptInterpreter
{
    enum BraceObjectCategoryEnum
    {
        /// <summary>
        /// Internal objects, no inheritance, handled specifically in the MemberCall/MemberSet/MemberGet/CollectionCall/CollectionSet/CollectionGet/LoopList APIs.
        /// </summary>
        BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT = 0,
        /// <summary>
        /// Internal special objects, handled specifically in the MemberCall/MemberSet/MemberGet/CollectionCall/CollectionSet/CollectionGet/LoopList APIs.
        /// </summary>
        BRACE_OBJECT_CATEGORY_OBJ_ARRAY,
        BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE,
        BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE,
        /// <summary>
        /// Custom structs, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_STRUCT,
        /// <summary>
        /// Custom objects, has inheritance, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_CUSTOM,
        /// <summary>
        /// Custom objects, inherit from UObject, can be used in UE api, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_UOBJECT,
        /// <summary>
        /// Custom objects, inherit from AActor, can be used in UE api, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_ACTOR,
        /// <summary>
        /// Custom objects, inherit from UActorComponent, can be used in UE api, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_ACTOR_COMPONENT,
        BRACE_OBJECT_CATEGORY_NUM
    };
    enum CustomBraceObjectTypeIdEnum
    {
        CUSTOM_BRACE_OBJECT_TYPE_STRING = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NUM,
        CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY,
        CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY,
        CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY,
        CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY,
        CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT,
        BRACE_INNER_FIXED_OBJECT_TYPE_NUM
    };

    struct MethodInfo final
    {
        Brace::DataTypeInfo ReturnType;
        std::vector<Brace::ParamTypeInfo> ParamTypes;
        std::string Name;
    };
    struct BraceObjectInfo;
    struct FieldInfo final
    {
        Brace::DataTypeInfo Type;
        int Offset;
        int Size;
        bool IsPtr;
        std::string Name;
        const BraceObjectInfo* BraceObjInfo;
    };
    struct MethodTableInfo final
    {
        std::vector<MethodInfo> Methods;
    };
    struct FieldTableInfo final
    {
        int Size;
        std::vector<FieldInfo> Fields;
    };
    struct BraceObjectInfo final
    {
        int GetTypeParamCount()const
        {
            auto& ps = TypeParams;
            return static_cast<int>(ps.size()) / 2;
        }
        int GetTypeParamType(int ix)const
        {
            auto& ps = TypeParams;
            int index = ix * 2;
            if (index >= 0 && index < static_cast<int>(ps.size())) {
                return ps[index];
            }
            return Brace::BRACE_DATA_TYPE_UNKNOWN;
        }
        int GetTypeParamObjTypeId(int ix)const
        {
            auto& ps = TypeParams;
            int index = ix * 2 + 1;
            if (index >= 0 && index < static_cast<int>(ps.size())) {
                return ps[index];
            }
            return Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN;
        }
        int FirstTypeParamType()const
        {
            return GetTypeParamType(0);
        }
        int FirstTypeParamObjTypeId()const
        {
            return GetTypeParamObjTypeId(0);
        }
        int SecondTypeParamType()const
        {
            return GetTypeParamType(1);
        }
        int SecondTypeParamObjTypeId()const
        {
            return GetTypeParamObjTypeId(1);
        }
        int LastTypeParamType()const
        {
            int ct = GetTypeParamCount();
            return GetTypeParamType(ct - 1);
        }
        int LastTypeParamObjTypeId()const
        {
            int ct = GetTypeParamCount();
            return GetTypeParamObjTypeId(ct - 1);
        }

        std::string TypeName;
        int ObjectTypeId;
        int ObjectCategory;
        std::vector<int> TypeParams;
        MethodTableInfo MethodTable;
        FieldTableInfo FieldTable;
    };

    class MemberCallExp;
    class MemberSetExp;
    class MemberGetExp;
    class CollectionCallExp;
    class CollectionSetExp;
    class CollectionGetExp;
    class LoopListExp;
    class LinqExp;
    class SelectExp;
    class AbstractMemberCallApiProvider : public Brace::BraceApiImplHelper
    {
        friend class MemberCallExp;
    protected:
        virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) = 0;
    protected:
        AbstractMemberCallApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractMemberSetApiProvider : public Brace::BraceApiImplHelper
    {
        friend class MemberSetExp;
    protected:
        virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) = 0;
    protected:
        AbstractMemberSetApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractMemberGetApiProvider : public Brace::BraceApiImplHelper
    {
        friend class MemberGetExp;
    protected:
        virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) = 0;
    protected:
        AbstractMemberGetApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractCollectionCallApiProvider : public Brace::BraceApiImplHelper
    {
        friend class CollectionCallExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) const = 0;
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo) const = 0;
    protected:
        AbstractCollectionCallApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractCollectionSetApiProvider : public Brace::BraceApiImplHelper
    {
        friend class CollectionSetExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, const Brace::OperandLoadtimeInfo& val, Brace::OperandLoadtimeInfo& resultInfo) const = 0;
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& val, const Brace::OperandRuntimeInfo& resultInfo) const = 0;
    protected:
        AbstractCollectionSetApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractCollectionGetApiProvider : public Brace::BraceApiImplHelper
    {
        friend class CollectionGetExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, Brace::OperandLoadtimeInfo& resultInfo) const = 0;
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& resultInfo) const = 0;
    protected:
        AbstractCollectionGetApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractLoopListApiProvider : public Brace::BraceApiImplHelper
    {
        friend class LoopListExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::ISyntaxComponent& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor) = 0;
        virtual void StoreRuntimeInfo(Brace::OperandRuntimeInfo&& listInfo, Brace::BraceApiExecutor&& list, std::vector<Brace::BraceApiExecutor>&& statements, const std::vector<int>& objVars) = 0;
    protected:
        AbstractLoopListApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractLinqApiProvider : public Brace::BraceApiImplHelper
    {
        friend class LinqExp;
    protected:
        virtual bool LoadLinqCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, Brace::OperandLoadtimeInfo&& listInfo, Brace::BraceApiExecutor&& list, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<int>&& objVars, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) = 0;
    protected:
        AbstractLinqApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractSelectApiProvider : public Brace::BraceApiImplHelper
    {
        friend class SelectExp;
    protected:
        enum StatMethodEnum
        {
            STAT_METHOD_NONE = -1,
            STAT_METHOD_MAX = 0,
            STAT_METHOD_MIN,
            STAT_METHOD_SUM,
            STAT_METHOD_AVG,
            STAT_METHOD_COUNT,
            MAX_STAT_METHOD_NUM
        };
    protected:
        virtual bool LoadSelect(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<int>&& statMethods, std::vector<int>&& objVars) = 0;
        virtual bool LoadTop(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, std::vector<int>&& objVars) = 0;
        virtual bool LoadFromList(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg) = 0;
        virtual bool LoadFromType(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const std::string& type) = 0;
        virtual bool LoadWhere(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, std::vector<int>&& objVars) = 0;
        virtual bool LoadOrderBy(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<bool>&& ascOrDescs, std::vector<int>&& objVars) = 0;
        virtual bool LoadGroupBy(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<int>&& objVars) = 0;
        virtual bool LoadHaving(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg) = 0;
        virtual bool LoadStatements(const Brace::FuncInfo& func, const DslData::FunctionData& data, std::vector<Brace::BraceApiExecutor>&& statements, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) = 0;
        virtual void LoadResultIterator(std::vector<Brace::OperandLoadtimeInfo>&& iterators, std::vector<int>&& objVars) = 0;
    protected:
        AbstractSelectApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    /// <summary>
    /// We make a objtypeid -> BraceObjectInfo map, which allows object category info to process class by category,
    /// Such as DispatchObject, CustomObject, UObject etc.
    /// </summary>
    class BraceObjectInfoManager final
    {
    public:
        int GetObjectTypeId(const std::string& key)const
        {
            auto it = m_ObjTypeIdMap.find(key);
            if (it != m_ObjTypeIdMap.end())
                return it->second;
            return Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN;
        }
        int AddNewObjectTypeId(const std::string& key)
        {
            int newId = GenNextObjectTypeId();
            m_ObjTypeIdMap.insert(std::make_pair(key, newId));
            return newId;
        }
        BraceObjectInfo* AddBraceObjectInfo(int objTypeId, int objCategory, const std::string& typeName)
        {
            std::string name = typeName;
            return AddBraceObjectInfo(objTypeId, objCategory, std::move(name));
        }
        BraceObjectInfo* AddBraceObjectInfo(int objTypeId, int objCategory, std::string&& typeName)
        {
            auto it = m_ObjTypeIdMap.find(typeName);
            if (it == m_ObjTypeIdMap.end()) {
                m_ObjTypeIdMap.insert(std::make_pair(typeName, objTypeId));
            }
            BraceObjectInfo info{};
            info.TypeName = std::move(typeName);
            info.ObjectCategory = objCategory;
            info.ObjectTypeId = objTypeId;
            auto pair = m_ObjInfoMap.insert(std::make_pair(objTypeId, std::move(info)));
            return pair.second ? &(pair.first->second) : nullptr;
        }
        void AddBraceObjectAlias(int objTypeId, std::string&& typeNameAlias)
        {
            auto it = m_ObjTypeIdMap.find(typeNameAlias);
            if (it == m_ObjTypeIdMap.end()) {
                m_ObjTypeIdMap.insert(std::make_pair(typeNameAlias, objTypeId));
            }
        }
        void SetBraceObjectTypeParams(int objTypeId, int param1Type, int param1ObjTypeId)
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                auto& ps = it->second.TypeParams;
                ps.clear();
                ps.push_back(param1Type);
                ps.push_back(param1ObjTypeId);
            }
        }
        void SetBraceObjectTypeParams(int objTypeId, int param1Type, int param1ObjTypeId, int param2Type, int param2ObjTypeId)
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                auto& ps = it->second.TypeParams;
                ps.clear();
                ps.push_back(param1Type);
                ps.push_back(param1ObjTypeId);
                ps.push_back(param2Type);
                ps.push_back(param2ObjTypeId);
            }
        }
        void ClearBraceObjectTypeParams(int objTypeId)
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                it->second.TypeParams.clear();
            }
        }
        void AddBraceObjectTypeParam(int objTypeId, int paramType, int paramObjTypeId)
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                auto& ps = it->second.TypeParams;
                ps.push_back(paramType);
                ps.push_back(paramObjTypeId);
            }
        }
        const std::string& GetBraceObjectTypeName(int objTypeId)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                return it->second.TypeName;
            }
            return EmptyString();
        }
        int GetBraceObjectCategory(int objTypeId)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                return it->second.ObjectCategory;
            }
            return INVALID_ID;
        }
        int GetBraceObjectTypeParamCount(int objTypeId)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                return it->second.GetTypeParamCount();
            }
            return 0;
        }
        int GetBraceObjectTypeParamType(int objTypeId, int ix)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                return it->second.GetTypeParamType(ix);
            }
            return Brace::BRACE_DATA_TYPE_UNKNOWN;
        }
        int GetBraceObjectTypeParamObjTypeId(int objTypeId, int ix)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                return it->second.GetTypeParamObjTypeId(ix);
            }
            return Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN;
        }
        int BraceObjectFirstTypeParamType(int objTypeId)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                return it->second.FirstTypeParamType();
            }
            return Brace::BRACE_DATA_TYPE_UNKNOWN;
        }
        int BraceObjectFirstTypeParamObjTypeId(int objTypeId)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                return it->second.FirstTypeParamType();
            }
            return Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN;
        }
        int BraceObjectSecondTypeParamType(int objTypeId)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                return it->second.SecondTypeParamType();
            }
            return Brace::BRACE_DATA_TYPE_UNKNOWN;
        }
        int BraceObjectSecondTypeParamObjTypeId(int objTypeId)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                return it->second.SecondTypeParamType();
            }
            return Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN;
        }
        int BraceObjectLastTypeParamType(int objTypeId)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                return it->second.LastTypeParamType();
            }
            return Brace::BRACE_DATA_TYPE_UNKNOWN;
        }
        int BraceObjectLastTypeParamObjTypeId(int objTypeId)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end()) {
                return it->second.LastTypeParamType();
            }
            return Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN;
        }
        const BraceObjectInfo* GetBraceObjectInfo(int objTypeId)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end())
                return &(it->second);
            return nullptr;
        }
        BraceObjectInfo* GetBraceObjectInfo(int objTypeId)
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end())
                return &(it->second);
            return nullptr;
        }
    public:
        bool TryGetOrAddBraceObjectInfo(const DslData::ISyntaxComponent& syntax, const Brace::LoadTypeInfoDelegation& doLoadTypeInfo, int& objTypeId)
        {
            bool ret = false;
            std::string key = CalcObjTypeKey(syntax, doLoadTypeInfo);
            objTypeId = GetObjectTypeId(key);
            if (objTypeId == Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN) {
                if (syntax.GetSyntaxType() == DslData::ISyntaxComponent::TYPE_FUNCTION) {
                    auto& funcData = static_cast<const DslData::FunctionData&>(syntax);
                    const std::string& id = syntax.GetId();
                    if (id == "decltype") {
                        auto& p = *funcData.GetParam(0);
                        Brace::OperandLoadtimeInfo loadInfo;
                        if (doLoadTypeInfo(p, loadInfo)) {
                            objTypeId = loadInfo.ObjectTypeId;
                            ret = true;
                        }
                    }
                    else if (id == "array") {
                        auto* p0 = funcData.GetParam(0);
                        int ot;
                        if (TryGetOrAddBraceObjectInfo(*p0, doLoadTypeInfo, ot)) {
                            objTypeId = AddNewObjectTypeId(key);
                            AddBraceObjectInfo(objTypeId, BRACE_OBJECT_CATEGORY_OBJ_ARRAY, std::move(key));
                            SetBraceObjectTypeParams(objTypeId, Brace::BRACE_DATA_TYPE_OBJECT, ot);
                            ret = true;
                        }
                    }
                    else if (id == "hashtable") {
                        const std::string& keyType = funcData.GetParamId(0);
                        int kt = Brace::GetDataType(keyType);
                        auto* p1 = funcData.GetParam(1);
                        int ot;
                        if (TryGetOrAddBraceObjectInfo(*p1, doLoadTypeInfo, ot)) {
                            objTypeId = AddNewObjectTypeId(key);
                            if (kt == Brace::BRACE_DATA_TYPE_STRING) {
                                AddBraceObjectInfo(objTypeId, BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE, std::move(key));
                                SetBraceObjectTypeParams(objTypeId, Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_OBJECT, ot);
                                ret = true;
                            }
                            else if (kt >= Brace::BRACE_DATA_TYPE_INT8 && kt <= Brace::BRACE_DATA_TYPE_UINT64) {
                                AddBraceObjectInfo(objTypeId, BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE, std::move(key));
                                SetBraceObjectTypeParams(objTypeId, Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_OBJECT, ot);
                                ret = true;
                            }
                        }
                    }
                }
            }
            else {
                ret = true;
            }
            return ret;
        }
    public:
        BraceObjectInfoManager() :m_ObjTypeIdMap(), m_ObjInfoMap(), m_NextObjectTypeId(BRACE_INNER_FIXED_OBJECT_TYPE_NUM)
        {}
    private:
        void CalcObjTypeKey(const DslData::ISyntaxComponent& syntax, const Brace::LoadTypeInfoDelegation& doLoadTypeInfo, std::stringstream& ss)
        {
            if (syntax.GetSyntaxType() == DslData::ISyntaxComponent::TYPE_FUNCTION) {
                auto& funcData = static_cast<const DslData::FunctionData&>(syntax);
                if (syntax.GetId() == "decltype") {
                    auto& p = *funcData.GetParam(0);
                    Brace::OperandLoadtimeInfo loadInfo;
                    if (doLoadTypeInfo(p, loadInfo)) {
                        CalcTypeInfoKey(loadInfo.Type, loadInfo.ObjectTypeId, ss);
                    }
                }
                else {
                    ss << syntax.GetId();
                    ss << "<:";
                    for (int ix = 0; ix < funcData.GetParamNum(); ++ix) {
                        if (ix > 0)
                            ss << ",";
                        auto& p = *funcData.GetParam(ix);
                        CalcObjTypeKey(p, doLoadTypeInfo, ss);
                    }
                    ss << ":>";
                }
            }
            else if (syntax.GetSyntaxType() == DslData::ISyntaxComponent::TYPE_VALUE) {
                ss << syntax.GetId();
            }
        }
        void CalcTypeInfoKey(int type, int objTypeId, std::stringstream& ss)
        {
            if (type == Brace::BRACE_DATA_TYPE_OBJECT) {
                ss << Brace::GetDataTypeName(type);
            }
            else {
                auto* pInfo = GetBraceObjectInfo(objTypeId);
                if (nullptr != pInfo) {
                    ss << pInfo->TypeName;
                    int size = static_cast<int>(pInfo->TypeParams.size());
                    if (size > 0) {
                        ss << "<:";
                        for (int i = 0; i + 1 < size; i += 2) {
                            int ty = pInfo->TypeParams[i];
                            int ot = pInfo->TypeParams[i + 1];
                            CalcTypeInfoKey(ty, ot, ss);
                        }
                        ss << ":>";
                    }
                }
                else {
                    ss << "[error]";
                }
            }
        }
        std::string CalcObjTypeKey(const DslData::ISyntaxComponent& syntax, const Brace::LoadTypeInfoDelegation& doLoadTypeInfo)
        {
            std::stringstream ss;
            CalcObjTypeKey(syntax, doLoadTypeInfo, ss);
            return ss.str();
        }
    private:
        int GenNextObjectTypeId()
        {
            return m_NextObjectTypeId++;
        }
    private:
        std::unordered_map<std::string, int> m_ObjTypeIdMap;
        std::unordered_map<int, BraceObjectInfo> m_ObjInfoMap;
        int m_NextObjectTypeId;
    public:
        static const std::string& EmptyString()
        {
            static std::string s_Empty{};
            return s_Empty;
        }
    };

    class MemorySize final
    {
    public:
        MemorySize(UObject* pObj)
        {
            m_pCountMem = new FArchiveCountMem(pObj, true);
            m_pResSize = new FResourceSizeEx(EResourceSizeMode::Exclusive);
            pObj->GetResourceSizeEx(*m_pResSize);
        }
        ~MemorySize()
        {
            delete m_pCountMem;
            delete m_pResSize;
        }
    public:
        uint64_t GetNum()const { return static_cast<uint64_t>(m_pCountMem->GetNum()); }
        uint64_t GetMax()const { return static_cast<uint64_t>(m_pCountMem->GetMax()); }
        uint64_t GetSysRes()const { return static_cast<uint64_t>(m_pResSize->GetDedicatedSystemMemoryBytes()); }
        uint64_t GetVideoRes()const { return static_cast<uint64_t>(m_pResSize->GetDedicatedVideoMemoryBytes()); }
        uint64_t GetSysSharedRes()const { return static_cast<uint64_t>(m_pResSize->GetSharedSystemMemoryBytes()); }
        uint64_t GetVideoSharedRes()const { return static_cast<uint64_t>(m_pResSize->GetSharedVideoMemoryBytes()); }
        uint64_t GetUnknownRes()const { return static_cast<uint64_t>(m_pResSize->GetUnknownMemoryBytes()); }
        uint64_t GetTotalRes()const { return static_cast<uint64_t>(m_pResSize->GetTotalMemoryBytes()); }
    private:
        FArchiveCountMem* m_pCountMem;
        FResourceSizeEx* m_pResSize;
    };
    template<typename T>
    class CppUnrealObjT final
    {
    public:
        CppUnrealObjT() :m_Impl(), m_pMemSize(nullptr)
        {}
        CppUnrealObjT(T* pImpl) :m_Impl(pImpl), m_pMemSize(nullptr)
        {}
        CppUnrealObjT(const TStrongObjectPtr<T>& ptr) :m_Impl(ptr)
        {}
        CppUnrealObjT(TStrongObjectPtr<T>&& ptr) :m_Impl(ptr)
        {}
        virtual ~CppUnrealObjT()
        {
            if (nullptr != m_pMemSize) {
                delete m_pMemSize;
                m_pMemSize = nullptr;
            }
        }
    public:
        T* GetImpl()const { return m_Impl.Get(); }
        void SetImpl(T* pImpl) { m_Impl.Reset(pImpl); }
        const MemorySize* GetOrCalcMemorySize()
        {
            auto* p = GetMemorySize();
            if (nullptr == p)
                p = ReCalcMemSize();
            return p;
        }
        const MemorySize* ReCalcMemSize()
        {
            if (m_Impl.Get()) {
                if (nullptr != m_pMemSize)
                    delete m_pMemSize;
                m_pMemSize = new MemorySize(m_Impl.Get());
            }
            return m_pMemSize;
        }
        const MemorySize* GetMemorySize()const { return m_pMemSize; }
    private:
        TStrongObjectPtr<T> m_Impl;
        MemorySize* m_pMemSize;
    };
    using UObjectBraceObject = CppUnrealObjT<UObject>;
    using AActorBraceObject = CppUnrealObjT<AActor>;

    class StructObj final
    {
    public:
        void AllocMemory(const BraceObjectInfo* pInfo)
        {
            m_pObjectInfo = pInfo;
            m_pMemory = new char[m_pObjectInfo->FieldTable.Size];
        }
        void SetMemory(const BraceObjectInfo* pInfo, void* pMemory)
        {
            m_pObjectInfo = pInfo;
            m_pMemory = reinterpret_cast<char*>(pMemory);
        }
        void CacheObjField(int offset, const std::shared_ptr<void>& ptr)
        {
            PrepareObjFields();
            (*m_pObjFields)[offset] = ptr;
        }
        std::shared_ptr<void>* GetCachedObjField(int offset)
        {
            PrepareObjFields();
            auto it = m_pObjFields->find(offset);
            if (it != m_pObjFields->end())
                return &(it->second);
            return nullptr;
        }
        void CacheStrField(int offset, const std::string& txt)
        {
            PrepareStrFields();
            (*m_pStrFields)[offset] = txt;
        }
        std::string* GetCachedStrField(int offset)
        {
            PrepareStrFields();
            auto it = m_pStrFields->find(offset);
            if (it != m_pStrFields->end())
                return &(it->second);
            return nullptr;
        }
        const BraceObjectInfo* GetObjectInfo()const { return m_pObjectInfo; }
        void* GetMemory()const { return m_pMemory; }
    public:
        StructObj() :m_pObjectInfo(nullptr), m_pMemory(nullptr), m_pObjFields(nullptr), m_pStrFields(nullptr)
        {}
        virtual ~StructObj()
        {
            if (nullptr != m_pMemory) {
                delete[] m_pMemory;
                m_pMemory = nullptr;
            }
        }
    private:
        void PrepareObjFields()
        {
            if (nullptr == m_pObjFields)
                m_pObjFields = new std::unordered_map<int, std::shared_ptr<void>>();
        }
        void PrepareStrFields()
        {
            if (nullptr == m_pStrFields)
                m_pStrFields = new std::unordered_map<int, std::string>();
        }
    private:
        const BraceObjectInfo* m_pObjectInfo;
        char* m_pMemory;
        std::unordered_map<int, std::shared_ptr<void>>* m_pObjFields;
        std::unordered_map<int, std::string>* m_pStrFields;
    };

    template<typename T>
    using ArrayT = std::vector<T>;
    using ObjectArray = std::vector<std::shared_ptr<void>>;

    template<typename KeyT, typename ValT>
    using HashtableT = std::unordered_map<KeyT, ValT>;
    using StrObjHashtable = std::unordered_map<std::string, std::shared_ptr<void>>;
    using IntObjHashtable = std::unordered_map<int64_t, std::shared_ptr<void>>;

    template<typename ValueTypeT>
    struct FStr2Type
    {
        static inline ValueTypeT Do(const FString& src)
        {
            return ValueTypeT{};
        }
    };
    template<>
    struct FStr2Type<std::string>
    {
        static inline std::string Do(const FString& src)
        {
            return TCHAR_TO_UTF8(*src);
        }
    };
    template<>
    struct FStr2Type<int64_t>
    {
        static inline int64_t Do(const FString& src)
        {
            return FCString::Atoi64(*src);
        }
    };
    template<>
    struct FStr2Type<double>
    {
        static inline double Do(const FString& src)
        {
            return FCString::Atod(*src);
        }
    };
    template<>
    struct FStr2Type<bool>
    {
        static inline bool Do(const FString& src)
        {
            return src == TEXT("true");
        }
    };

    template<typename ValueTypeT>
    struct Type2FStr
    {
        static inline FString Do(const ValueTypeT& src)
        {
            return FString{};
        }
    };
    template<>
    struct Type2FStr<std::string>
    {
        static inline FString Do(const std::string& src)
        {
            return TCHAR_TO_UTF8(src.c_str());
        }
    };
    template<>
    struct Type2FStr<int64_t>
    {
        static inline FString Do(int64_t src)
        {
            return UTF8_TO_TCHAR(std::to_string(src).c_str());
        }
    };
    template<>
    struct Type2FStr<double>
    {
        static inline FString Do(double src)
        {
            return UTF8_TO_TCHAR(std::to_string(src).c_str());
        }
    };
    template<>
    struct Type2FStr<bool>
    {
        static inline FString Do(bool src)
        {
            return src ? TEXT("true") : TEXT("false");
        }
    };

    thread_local static BraceObjectInfoManager g_ObjectInfoMgr;

    template<typename... TReturns, typename... TArgs>
    static inline void InvokeFunction(UClass* objClass, UObject* obj, UFunction* func, TTuple<TReturns...>& outParams, TArgs&&... args)
    {
        objClass = obj != nullptr ? obj->GetClass() : objClass;
        UObject* context = obj != nullptr ? obj : objClass;
        uint8* outPramsBuffer = (uint8*)&outParams;

        if (func->HasAnyFunctionFlags(FUNC_Native)) //quick path for c++ functions
        {
            TTuple<TArgs..., TReturns...> params(Forward<TArgs>(args)..., TReturns()...);
            context->ProcessEvent(func, &params);
            //copy back out params
            for (TFieldIterator<FProperty> i(func); i; ++i) {
                FProperty* prop = *i;
                if (prop->PropertyFlags & CPF_OutParm) {
                    void* propBuffer = prop->ContainerPtrToValuePtr<void*>(&params);
                    prop->CopyCompleteValue(outPramsBuffer, propBuffer);
                    outPramsBuffer += prop->GetSize();
                }
            }
            return;
        }

        TTuple<TArgs...> inParams(Forward<TArgs>(args)...);
        void* funcPramsBuffer = (uint8*)FMemory_Alloca(func->ParmsSize);
        uint8* inPramsBuffer = (uint8*)&inParams;

        for (TFieldIterator<FProperty> i(func); i; ++i) {
            FProperty* prop = *i;
            if (prop->GetFName().ToString().StartsWith("__")) {
                //ignore private param like __WolrdContext of function in blueprint funcion library
                continue;
            }
            void* propBuffer = prop->ContainerPtrToValuePtr<void*>(funcPramsBuffer);
            if (prop->PropertyFlags & CPF_OutParm) {
                prop->CopyCompleteValue(propBuffer, outPramsBuffer);
                outPramsBuffer += prop->GetSize();
            }
            else if (prop->PropertyFlags & CPF_Parm) {
                prop->CopyCompleteValue(propBuffer, inPramsBuffer);
                inPramsBuffer += prop->GetSize();
            }
        }

        context->ProcessEvent(func, funcPramsBuffer);   //call function
        outPramsBuffer = (uint8*)&outParams;    //reset to begin

        //copy back out params
        for (TFieldIterator<FProperty> i(func); i; ++i) {
            FProperty* prop = *i;
            if (prop->PropertyFlags & CPF_OutParm) {
                void* propBuffer = prop->ContainerPtrToValuePtr<void*>(funcPramsBuffer);
                prop->CopyCompleteValue(outPramsBuffer, propBuffer);
                outPramsBuffer += prop->GetSize();
            }
        }
    }
    static inline std::string CalcObjDesc(const UObject* obj)
    {
        const UFunction* pFunc = Cast<UFunction>(obj);
        if (nullptr != pFunc) {
            std::stringstream ss;
            FString gname = pFunc->GetFullGroupName(false);
            FProperty* pRet = pFunc->GetReturnProperty();
            if (nullptr != pRet) {
                FString rname = pRet->GetCPPType();
                ss << TCHAR_TO_UTF8(*rname) << ' ' << TCHAR_TO_UTF8(*gname) << '(';
            }
            else {
                ss << "void" << ' ' << TCHAR_TO_UTF8(*gname) << '(';
            }
            bool first = true;
            for (TFieldIterator<FProperty> fit(pFunc); fit; ++fit) {
                EPropertyFlags flags = fit->GetPropertyFlags();
                if (flags & CPF_ReturnParm) {
                    continue;
                }
                if (!first)
                    ss << ", ";
                if (flags & CPF_Parm) {
                    ss << "[in]";
                }
                if (flags & CPF_OutParm) {
                    ss << "[out]";
                }
                ss << TCHAR_TO_UTF8(*fit->GetCPPType()) << ' ' << TCHAR_TO_UTF8(*fit->GetFName().ToString());
                first = false;
            }
            ss << ')';
            return ss.str();
        }
        else {
            std::stringstream ss;
            UClass* pClass = obj->GetClass();
            FString gname = pClass->GetFullGroupName(false);
            ss << TCHAR_TO_UTF8(*gname);
            ss << '[';
            FString pname = obj->GetPathName();
            ss << TCHAR_TO_UTF8(*pname);
            ss << ',';
            FPrimaryAssetId assetId = obj->GetPrimaryAssetId();
            if (assetId.IsValid())
                ss << TCHAR_TO_UTF8(*assetId.ToString());
            ss << ',';
            UPackage* pPackage = obj->GetPackage();
            if (nullptr != pPackage) {
#if UE_EDITOR
                FGuid guid = pPackage->GetPersistentGuid();
                if (guid.IsValid()) {
                    ss << TCHAR_TO_UTF8(*guid.ToString());
                }
#endif
            }
            ss << ']';
            return ss.str();
        }
    }
    static inline std::string GetObjectFlags(UObject* pObj)
    {
        std::stringstream ss;
        if (pObj->IsRooted()) {
            ss << "(root) ";
        }
        if (pObj->IsNative()) {
            ss << "(native) ";
        }
        if (pObj->IsPendingKill()) {
            ss << "(PendingKill) ";
        }
        if (pObj->HasAnyFlags(RF_Standalone)) {
            ss << "(standalone) ";
        }
        if (pObj->HasAnyInternalFlags(EInternalObjectFlags::Async)) {
            ss << "(async) ";
        }
        if (pObj->HasAnyInternalFlags(EInternalObjectFlags::AsyncLoading)) {
            ss << "(asyncloading) ";
        }
        if (GUObjectArray.IsDisregardForGC(pObj)) {
            ss << "(NeverGCed) ";
        }
        FUObjectItem* ReferencedByObjectItem = GUObjectArray.ObjectToObjectItem(pObj);
        if (ReferencedByObjectItem->HasAnyFlags(EInternalObjectFlags::ClusterRoot)) {
            ss << "(ClusterRoot) ";
        }
        if (ReferencedByObjectItem->GetOwnerIndex() > 0) {
            ss << "(Clustered) ";
        }
        return ss.str();
    }
    class CastExp final : public Brace::AbstractBraceApi
    {
    public:
        CastExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_AssignPtr(nullptr), m_ResultInfo()
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            //cast(exp, type)
            if (data.GetParamNum() != 2)
                return false;
            auto* type = data.GetParam(1);
            auto typeInfo = ParseParamTypeInfo(*type);

            Brace::OperandLoadtimeInfo info;
            info.Type = typeInfo.Type;
            info.ObjectTypeId = typeInfo.ObjectTypeId;
            auto expExecutor = LoadHelper(*data.GetParam(0), info);
            if (Brace::DataTypeInfo::IsSameType(info, typeInfo)) {
                resultInfo = info;
                std::swap(executor, expExecutor);
                return true;
            }
            else if (!Brace::IsObjectType(typeInfo.Type) && !Brace::IsObjectType(info.Type)) {
                auto fptr = Brace::GetVarAssignPtr(typeInfo.Type, false, info.Type, false);
                if (nullptr != fptr) {
                    m_AssignPtr = fptr;
                    resultInfo.Type = typeInfo.Type;
                    resultInfo.ObjectTypeId = typeInfo.ObjectTypeId;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                    m_ExpInfo = info;
                    std::swap(m_Exp, expExecutor);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &CastExp::Execute);
                }
            }
            std::stringstream ss;
            ss << "expected cast(exp, type), line: " << data.GetLine();
            LogError(ss.str());
            executor = nullptr;
            return false;
        }
    private:
        int Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Exp.isNull())
                m_Exp(gvars, lvars);
            (*m_AssignPtr)((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, (m_ExpInfo.IsGlobal ? gvars : lvars), m_ExpInfo.VarIndex);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    private:
        Brace::VarAssignPtr m_AssignPtr;
        Brace::OperandRuntimeInfo m_ExpInfo;
        Brace::BraceApiExecutor m_Exp;
        Brace::OperandRuntimeInfo m_ResultInfo;
    };
    class TypeTagExp final : public Brace::AbstractBraceApi
    {
    public:
        TypeTagExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            //typetag(type) or typetag(exp)
            if (data.GetParamNum() != 1) {
                std::stringstream ss;
                ss << "expected typetag(type) or typetag(exp), line: " << data.GetLine();
                LogError(ss.str());
                return false;
            }
            auto* typeOrExp = data.GetParam(0);
            auto typeInfo = ParseParamTypeInfo(*typeOrExp);
            if (Brace::IsUnknownType(typeInfo.Type) || typeInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT && typeInfo.ObjectTypeId <= 0) {
                Brace::OperandLoadtimeInfo loadInfo;
                LoadHelper(*typeOrExp, loadInfo);
                typeInfo.Type = loadInfo.Type;
                typeInfo.ObjectTypeId = loadInfo.ObjectTypeId;
            }

            resultInfo.Type = typeInfo.Type;
            resultInfo.ObjectTypeId = typeInfo.ObjectTypeId;
            resultInfo.Name = "loadtimevar";
            resultInfo.VarIndex = INVALID_INDEX;

            executor = nullptr;
            return true;
        }
    };
    class TypeIdExp final : public Brace::AbstractBraceApi
    {
    public:
        TypeIdExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            //typeid(type) or typeid(exp)
            if (data.GetParamNum() != 1) {
                std::stringstream ss;
                ss << "expected typeid(type) or typeid(exp), line: " << data.GetLine();
                LogError(ss.str());
                return false;
            }
            int type = Brace::BRACE_DATA_TYPE_UNKNOWN;
            auto* typeOrExp = data.GetParam(0);
            auto typeInfo = ParseParamTypeInfo(*typeOrExp);
            if (Brace::IsUnknownType(typeInfo.Type) || typeInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT && typeInfo.ObjectTypeId <= 0) {
                Brace::OperandLoadtimeInfo loadInfo;
                LoadHelper(*typeOrExp, loadInfo);
                type = loadInfo.Type;
            }
            else {
                type = typeInfo.Type;
            }

            std::string varId = std::to_string(type);
            auto* info = GetConstInfo(DslData::ValueData::VALUE_TYPE_NUM, varId);
            if (nullptr != info) {
                resultInfo.Type = info->Type;
                resultInfo.ObjectTypeId = info->ObjectTypeId;
                resultInfo.VarIndex = info->VarIndex;
                resultInfo.IsGlobal = true;
                resultInfo.IsTempVar = false;
                resultInfo.IsConst = true;
                resultInfo.Name = varId;
            }
            else {
                resultInfo.VarIndex = AllocConst(DslData::ValueData::VALUE_TYPE_NUM, varId, resultInfo.Type, resultInfo.ObjectTypeId);
                resultInfo.IsGlobal = true;
                resultInfo.IsTempVar = false;
                resultInfo.IsConst = true;
                resultInfo.Name = varId;
            }
            executor = nullptr;
            return true;
        }
    };
    class ObjTypeIdExp final : public Brace::AbstractBraceApi
    {
    public:
        ObjTypeIdExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            //objtypeid(type) or objtypeid(exp)
            if (data.GetParamNum() != 1) {
                std::stringstream ss;
                ss << "expected objtypeid(type) or objtypeid(exp), line: " << data.GetLine();
                LogError(ss.str());
                return false;
            }
            int type = Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN;
            auto* typeOrExp = data.GetParam(0);
            auto typeInfo = ParseParamTypeInfo(*typeOrExp);
            if (Brace::IsUnknownType(typeInfo.Type) || typeInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT && typeInfo.ObjectTypeId <= Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ) {
                Brace::OperandLoadtimeInfo loadInfo;
                LoadHelper(*typeOrExp, loadInfo);
                type = loadInfo.ObjectTypeId;
            }
            else {
                type = typeInfo.ObjectTypeId;
            }

            std::string varId = std::to_string(type);
            auto* info = GetConstInfo(DslData::ValueData::VALUE_TYPE_NUM, varId);
            if (nullptr != info) {
                resultInfo.Type = info->Type;
                resultInfo.ObjectTypeId = info->ObjectTypeId;
                resultInfo.VarIndex = info->VarIndex;
                resultInfo.IsGlobal = true;
                resultInfo.IsTempVar = false;
                resultInfo.IsConst = true;
                resultInfo.Name = varId;
            }
            else {
                resultInfo.VarIndex = AllocConst(DslData::ValueData::VALUE_TYPE_NUM, varId, resultInfo.Type, resultInfo.ObjectTypeId);
                resultInfo.IsGlobal = true;
                resultInfo.IsTempVar = false;
                resultInfo.IsConst = true;
                resultInfo.Name = varId;
            }
            executor = nullptr;
            return true;
        }
    };
    class GetObjTypeNameExp final : public Brace::SimpleBraceApiBase
    {
    public:
        GetObjTypeNameExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter)
        {
        }
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
        {
            if (argInfos.size() == 1) {
                auto& argInfo = argInfos[0];
                if (argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                    resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    return true;
                }
            }
            std::stringstream ss;
            ss << "expected getobjtypename(objtypeid), line: " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
        {
            auto& argInfo = argInfos[0];
            int objTypeId = static_cast<int>(Brace::VarGetI64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex));
            const std::string& v = g_ObjectInfoMgr.GetBraceObjectTypeName(objTypeId);
            Brace::VarSetString((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
        }
    };
    class GetObjCategoryExp final : public Brace::SimpleBraceApiBase
    {
    public:
        GetObjCategoryExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter)
        {
        }
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
        {
            if (argInfos.size() == 1) {
                auto& argInfo = argInfos[0];
                if (argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_INT32;
                    resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    return true;
                }
            }
            std::stringstream ss;
            ss << "expected getobjcategory(objtypeid), line: " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
        {
            auto& argInfo = argInfos[0];
            int objTypeId = static_cast<int>(Brace::VarGetI64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex));
            int v = g_ObjectInfoMgr.GetBraceObjectCategory(objTypeId);
            Brace::VarSetInt32((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
        }
    };
    class GetTypeParamCountExp final : public Brace::SimpleBraceApiBase
    {
    public:
        GetTypeParamCountExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter)
        {
        }
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
        {
            if (argInfos.size() == 1) {
                auto& argInfo = argInfos[0];
                if (argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_INT32;
                    resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    return true;
                }
            }
            std::stringstream ss;
            ss << "expected gettypeparamcount(objtypeid), line: " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
        {
            auto& argInfo = argInfos[0];
            int objTypeId = static_cast<int>(Brace::VarGetI64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex));
            int v = g_ObjectInfoMgr.GetBraceObjectTypeParamCount(objTypeId);
            Brace::VarSetInt32((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
        }
    };
    class GetTypeParamTypeExp final : public Brace::SimpleBraceApiBase
    {
    public:
        GetTypeParamTypeExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter)
        {
        }
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
        {
            if (argInfos.size() == 2) {
                auto& argInfo = argInfos[0];
                auto& argInfo2 = argInfos[1];
                if (argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64 && argInfo2.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo2.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_INT32;
                    resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    return true;
                }
            }
            std::stringstream ss;
            ss << "expected gettypeparamtype(objtypeid, index), line: " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
        {
            auto& argInfo = argInfos[0];
            auto& argInfo2 = argInfos[1];
            int objTypeId = static_cast<int>(Brace::VarGetI64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex));
            int index = static_cast<int>(Brace::VarGetI64((argInfo2.IsGlobal ? gvars : lvars), argInfo2.Type, argInfo2.VarIndex));
            int v = g_ObjectInfoMgr.GetBraceObjectTypeParamType(objTypeId, index);
            Brace::VarSetInt32((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
        }
    };
    class GetTypeParamObjTypeIdExp final : public Brace::SimpleBraceApiBase
    {
    public:
        GetTypeParamObjTypeIdExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter)
        {
        }
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
        {
            if (argInfos.size() == 2) {
                auto& argInfo = argInfos[0];
                auto& argInfo2 = argInfos[1];
                if (argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64 && argInfo2.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo2.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_INT32;
                    resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    return true;
                }
            }
            std::stringstream ss;
            ss << "expected gettypeparamobjtypeid(objtypeid, index), line: " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
        {
            auto& argInfo = argInfos[0];
            auto& argInfo2 = argInfos[1];
            int objTypeId = static_cast<int>(Brace::VarGetI64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex));
            int index = static_cast<int>(Brace::VarGetI64((argInfo2.IsGlobal ? gvars : lvars), argInfo2.Type, argInfo2.VarIndex));
            int v = g_ObjectInfoMgr.GetBraceObjectTypeParamObjTypeId(objTypeId, index);
            Brace::VarSetInt32((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
        }
    };
    class SwapExp final : public Brace::AbstractBraceApi
    {
    public:
        SwapExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_Var1Info(), m_Var2Info()
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            //swap(var1, var2)
            if (data.GetParamNum() != 2) {
                std::stringstream ss;
                ss << "expected swap(var1, var2), line: " << data.GetLine();
                LogError(ss.str());
                return false;
            }
            DslData::ISyntaxComponent* param1 = data.GetParam(0);
            DslData::ISyntaxComponent* param2 = data.GetParam(1);
            if (param1->GetSyntaxType() != DslData::ISyntaxComponent::TYPE_VALUE || param2->GetSyntaxType() != DslData::ISyntaxComponent::TYPE_VALUE) {
                std::stringstream ss;
                ss << "expected swap(var1, var2), var1 and var2 must be local var or global var, line: " << data.GetLine();
                LogError(ss.str());
                return false;
            }
            const std::string& varId1 = param1->GetId();
            const std::string& varId2 = param2->GetId();
            bool var1IsGlobal = varId1.length() > 0 && varId1[0] == '@';
            bool var2IsGlobal = varId2.length() > 0 && varId2[0] == '@';
            Brace::VarInfo* varInfo1 = nullptr;
            Brace::VarInfo* varInfo2 = nullptr;
            if (var1IsGlobal)
                varInfo1 = GetGlobalVarInfo(varId1);
            else
                varInfo1 = GetVarInfo(varId1);
            if (var2IsGlobal)
                varInfo2 = GetGlobalVarInfo(varId2);
            else
                varInfo2 = GetVarInfo(varId2);
            if (nullptr == varInfo1) {
                std::stringstream ss;
                ss << "can't find var " << varId1 << ", line: " << data.GetLine();
                LogError(ss.str());
                return false;
            }
            if (nullptr == varInfo2) {
                std::stringstream ss;
                ss << "can't find var " << varId2 << ", line: " << data.GetLine();
                LogError(ss.str());
                return false;
            }
            if (varInfo1->Type != varInfo2->Type || varInfo1->ObjectTypeId != varInfo2->ObjectTypeId) {
                std::stringstream ss;
                ss << varId1 << " and " << varId2 << " must be same type, line: " << data.GetLine();
                LogError(ss.str());
                return false;
            }
            if (varInfo1->Type == Brace::BRACE_DATA_TYPE_REF) {
                auto& ref1 = func.VarInitInfo.ReferenceVars[varInfo1->VarIndex];
                auto& ref2 = func.VarInitInfo.ReferenceVars[varInfo2->VarIndex];
                if (ref1.Type != ref2.Type || ref1.ObjectTypeId != ref2.ObjectTypeId) {
                    std::stringstream ss;
                    ss << varId1 << " and " << varId2 << " must be same type, line: " << data.GetLine();
                    LogError(ss.str());
                    return false;
                }
            }
            m_Var1Info.Type = static_cast<int8_t>(varInfo1->Type);
            m_Var1Info.ObjectTypeId = varInfo1->ObjectTypeId;
            m_Var1Info.VarIndex = static_cast<int16_t>(varInfo1->VarIndex);
            m_Var1Info.IsGlobal = (var1IsGlobal ? 1 : 0);

            m_Var2Info.Type = static_cast<int8_t>(varInfo2->Type);
            m_Var2Info.ObjectTypeId = varInfo2->ObjectTypeId;
            m_Var2Info.VarIndex = static_cast<int16_t>(varInfo2->VarIndex);
            m_Var2Info.IsGlobal = (var2IsGlobal ? 1 : 0);

            executor.attach(this, &SwapExp::Execute);
            return true;
        }
    private:
        int Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            //todo:split by tuple (var, global/local vars, type) for performance, maybe 104 functions, a lot of work..
            auto& vars1 = (m_Var1Info.IsGlobal ? gvars : lvars);
            auto& vars2 = (m_Var2Info.IsGlobal ? gvars : lvars);
            int index1 = m_Var1Info.VarIndex;
            int index2 = m_Var2Info.VarIndex;
            int type = m_Var1Info.Type;

            DoSwap(type, vars1, vars2, index1, index2);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    private:
        void DoSwap(int type, Brace::VariableInfo& vars1, Brace::VariableInfo& vars2, int index1, int index2)const
        {
            switch (type) {
            case Brace::BRACE_DATA_TYPE_BOOL: {
                bool v1 = Brace::VarGetBool(vars1, index1);
                bool v2 = Brace::VarGetBool(vars2, index2);
                Brace::VarSetBool(vars1, index1, v2);
                Brace::VarSetBool(vars2, index2, v1);
            }break;
            case Brace::BRACE_DATA_TYPE_INT8: {
                int8_t v1 = Brace::VarGetInt8(vars1, index1);
                int8_t v2 = Brace::VarGetInt8(vars2, index2);
                Brace::VarSetInt8(vars1, index1, v2);
                Brace::VarSetInt8(vars2, index2, v1);
            }break;
            case Brace::BRACE_DATA_TYPE_UINT8: {
                uint8_t v1 = Brace::VarGetUInt8(vars1, index1);
                uint8_t v2 = Brace::VarGetUInt8(vars2, index2);
                Brace::VarSetUInt8(vars1, index1, v2);
                Brace::VarSetUInt8(vars2, index2, v1);
            }break;
            case Brace::BRACE_DATA_TYPE_INT16: {
                int16_t v1 = Brace::VarGetInt16(vars1, index1);
                int16_t v2 = Brace::VarGetInt16(vars2, index2);
                Brace::VarSetInt16(vars1, index1, v2);
                Brace::VarSetInt16(vars2, index2, v1);
            }break;
            case Brace::BRACE_DATA_TYPE_UINT16: {
                uint16_t v1 = Brace::VarGetUInt16(vars1, index1);
                uint16_t v2 = Brace::VarGetUInt16(vars2, index2);
                Brace::VarSetUInt16(vars1, index1, v2);
                Brace::VarSetUInt16(vars2, index2, v1);
            }break;
            case Brace::BRACE_DATA_TYPE_INT32: {
                int32_t v1 = Brace::VarGetInt32(vars1, index1);
                int32_t v2 = Brace::VarGetInt32(vars2, index2);
                Brace::VarSetInt32(vars1, index1, v2);
                Brace::VarSetInt32(vars2, index2, v1);
            }break;
            case Brace::BRACE_DATA_TYPE_UINT32: {
                uint32_t v1 = Brace::VarGetUInt32(vars1, index1);
                uint32_t v2 = Brace::VarGetUInt32(vars2, index2);
                Brace::VarSetUInt32(vars1, index1, v2);
                Brace::VarSetUInt32(vars2, index2, v1);
            }break;
            case Brace::BRACE_DATA_TYPE_INT64: {
                int64_t v1 = Brace::VarGetInt64(vars1, index1);
                int64_t v2 = Brace::VarGetInt64(vars2, index2);
                Brace::VarSetInt64(vars1, index1, v2);
                Brace::VarSetInt64(vars2, index2, v1);
            }break;
            case Brace::BRACE_DATA_TYPE_UINT64: {
                uint64_t v1 = Brace::VarGetUInt64(vars1, index1);
                uint64_t v2 = Brace::VarGetUInt64(vars2, index2);
                Brace::VarSetUInt64(vars1, index1, v2);
                Brace::VarSetUInt64(vars2, index2, v1);
            }break;
            case Brace::BRACE_DATA_TYPE_FLOAT: {
                float v1 = Brace::VarGetFloat(vars1, index1);
                float v2 = Brace::VarGetFloat(vars2, index2);
                Brace::VarSetFloat(vars1, index1, v2);
                Brace::VarSetFloat(vars2, index2, v1);
            }break;
            case Brace::BRACE_DATA_TYPE_DOUBLE: {
                double v1 = Brace::VarGetDouble(vars1, index1);
                double v2 = Brace::VarGetDouble(vars2, index2);
                Brace::VarSetDouble(vars1, index1, v2);
                Brace::VarSetDouble(vars2, index2, v1);
            }break;
            case Brace::BRACE_DATA_TYPE_STRING: {
                std::string v1 = Brace::VarGetString(vars1, index1);
                const std::string& v2 = Brace::VarGetString(vars2, index2);
                Brace::VarSetString(vars1, index1, v2);
                Brace::VarSetString(vars2, index2, v1);
            }break;
            case Brace::BRACE_DATA_TYPE_OBJECT: {
                auto v1 = Brace::VarGetObject(vars1, index1);
                auto& v2 = Brace::VarGetObject(vars2, index2);
                Brace::VarSetObject(vars1, index1, v2);
                Brace::VarSetObject(vars2, index2, v1);
            }break;
            case Brace::BRACE_DATA_TYPE_REF: {
                auto& ref1 = Brace::VarGetRef(vars1, index1);
                auto& ref2 = Brace::VarGetRef(vars2, index2);

                DoSwap(ref1.Type, *ref1.Vars, *ref2.Vars, ref1.VarIndex, ref2.VarIndex);
            }break;
            }
        }
    private:
        Brace::OperandRuntimeInfo m_Var1Info;
        Brace::OperandRuntimeInfo m_Var2Info;
    };

    class UObjectMemberCallProvider final : public AbstractMemberCallApiProvider
    {
        friend class MemberCallExp;
    protected:
        virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
        {
            if (member == "DumpRefs") {
                executor.attach(this, &UObjectMemberCallProvider::ExecuteDumpRefs);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                std::swap(m_Member, member);
                return true;
            }
            else if (member == "CalcMemInfo") {
                if (argInfos.size() > 0) {
                    std::stringstream ss;
                    ss << "expected uobject.CalcMemInfo(), line: " << data.GetLine();
                    LogError(ss.str());
                    executor = nullptr;
                    return false;
                }
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                m_ResultInfo = resultInfo;
                executor.attach(this, &UObjectMemberCallProvider::ExecuteCalcMemInfo);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                std::swap(m_Member, member);
                return true;
            }
            else if (member == "CalcFlagInfo") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                m_ResultInfo = resultInfo;
                executor.attach(this, &UObjectMemberCallProvider::ExecuteCalcFlagInfo);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                std::swap(m_Member, member);
                return true;
            }
            else {
                //try call by reflection
                if (resultInfo.Type != Brace::BRACE_DATA_TYPE_UNKNOWN) {
                    if (resultInfo.VarIndex == INVALID_INDEX) {
                        resultInfo.IsGlobal = false;
                        resultInfo.Name = GenTempVarName();
                        resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                        m_ResultInfo = resultInfo;
                    }
                    if (Brace::IsObjectType(resultInfo.Type)) {
                        m_ResultObjInfo = g_ObjectInfoMgr.GetBraceObjectInfo(resultInfo.ObjectTypeId);
                    }
                }
                executor.attach(this, &UObjectMemberCallProvider::ExecuteReflection);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                for (auto&& argInfo : argInfos) {
                    m_ArgInfos.push_back(argInfo);
                    if (Brace::IsObjectType(argInfo.Type)) {
                        auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(argInfo.ObjectTypeId);
                        m_ArgObjInfos.push_back(pInfo);
                    }
                    else {
                        m_ArgObjInfos.push_back(nullptr);
                    }
                }
                std::swap(m_Args, args);
                std::swap(m_Member, member);
                return true;
            }
        }
    private:
        int ExecuteDumpRefs(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                FReferenceChainSearch refSearch(pObj, EReferenceChainSearchMode::Default);
                const TArray<FReferenceChainSearch::FReferenceChain*>& referenceChains = refSearch.GetReferenceChains();
                if (referenceChains.Num()) {
                    const int32 maxChainsToPrint = 100;
                    int32 numPrintedChains = 0;

                    for (FReferenceChainSearch::FReferenceChain* chain : referenceChains) {
                        if (numPrintedChains < maxChainsToPrint) {
                            DumpChain(chain);
                            numPrintedChains++;
                        }
                        else {
                            std::stringstream ss;
                            ss << "Referenced by" << referenceChains.Num() - numPrintedChains << "more reference chain(s).";
                            std::string str = ss.str();
                            LogInfo(str);
                            LogToDebug(UTF8_TO_TCHAR(str.c_str()));
                            break;
                        }
                    }
                }
                else {
                    std::stringstream ss;
                    ss << GetObjectFlags(pObj) << TCHAR_TO_UTF8(*pObj->GetFullName());
                    std::string str = ss.str();
                    LogInfo(str);
                    LogToDebug(UTF8_TO_TCHAR(str.c_str()));
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteCalcMemInfo(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, "");
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                if (nullptr != pObj) {
                    auto* pMemSize = scpObj->GetOrCalcMemorySize();
                    std::string fname = TCHAR_TO_UTF8(*pObj->GetFullGroupName(false));
                    uint64_t numMem = pMemSize->GetNum();
                    uint64_t maxMem = pMemSize->GetMax();
                    uint64_t sysRes = pMemSize->GetSysRes();
                    uint64_t videoRes = pMemSize->GetVideoRes();
                    uint64_t sysShared = pMemSize->GetSysSharedRes();
                    uint64_t videoShared = pMemSize->GetVideoSharedRes();
                    uint64_t unknownRes = pMemSize->GetUnknownRes();
                    uint64_t totalRes = pMemSize->GetTotalRes();
                    std::stringstream ss;
                    ss << fname << "," << numMem << "," << maxMem << "," << sysRes << "," << videoRes << "," << sysShared << "," << videoShared << "," << unknownRes << "," << totalRes;
                    Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, ss.str());
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteCalcFlagInfo(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, "");
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                if (nullptr != pObj) {
                    std::string str = GetObjectFlags(pObj);
                    Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, str);
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteReflection(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            for (auto&& arg : m_Args) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                UFunction* pFunc = pObj->FindFunction(FName(m_Member.c_str()));
                if (nullptr != pFunc) {
                    // Parse all function parameters.
                    uint8* funcPramsBuffer = reinterpret_cast<uint8*>(FMemory_Alloca(pFunc->ParmsSize));
                    FMemory::Memzero(funcPramsBuffer, pFunc->ParmsSize);

                    for (TFieldIterator<FProperty> it(pFunc); it && it->HasAnyPropertyFlags(CPF_Parm); ++it) {
                        FProperty* localProp = *it;
                        checkSlow(localProp);
                        if (!localProp->HasAnyPropertyFlags(CPF_ZeroConstructor)) {
                            localProp->InitializeValue_InContainer(funcPramsBuffer);
                        }
                    }

                    uint8 inParamBuffer[8];
                    int argIndex = 0;
                    for (TFieldIterator<FProperty> it(pFunc); it; ++it) {
                        FProperty* prop = *it;
                        if (prop->GetFName().ToString().StartsWith("__")) {
                            //ignore private param like __WolrdContext of function in blueprint funcion library
                            continue;
                        }
                        void* propBuffer = prop->ContainerPtrToValuePtr<void*>(funcPramsBuffer);
                        if (prop->PropertyFlags & CPF_OutParm) {
                            FMemory::Memzero(propBuffer, prop->GetSize());
                        }
                        else if (prop->PropertyFlags & CPF_Parm && argIndex < static_cast<int>(m_ArgInfos.size())) {
                            bool argIsStruct = false;
                            int size = prop->GetSize();
                            FMemory::Memzero(inParamBuffer, sizeof(inParamBuffer));
                            auto& argInfo = m_ArgInfos[argIndex];
                            switch (argInfo.Type) {
                            case Brace::BRACE_DATA_TYPE_BOOL: {
                                bool v = Brace::VarGetBool((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                FMemory::Memcpy(inParamBuffer, &v, sizeof(bool));
                            }break;
                            case Brace::BRACE_DATA_TYPE_INT8: {
                                int8_t v = Brace::VarGetInt8((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                FMemory::Memcpy(inParamBuffer, &v, sizeof(int8_t));
                            }break;
                            case Brace::BRACE_DATA_TYPE_UINT8: {
                                uint8_t v = Brace::VarGetUInt8((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                FMemory::Memcpy(inParamBuffer, &v, sizeof(uint8_t));
                            }break;
                            case Brace::BRACE_DATA_TYPE_INT16: {
                                int16_t v = Brace::VarGetInt16((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                FMemory::Memcpy(inParamBuffer, &v, sizeof(int16_t));
                            }break;
                            case Brace::BRACE_DATA_TYPE_UINT16: {
                                uint16_t v = Brace::VarGetUInt16((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                FMemory::Memcpy(inParamBuffer, &v, sizeof(uint16_t));
                            }break;
                            case Brace::BRACE_DATA_TYPE_INT32: {
                                int32_t v = Brace::VarGetInt32((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                FMemory::Memcpy(inParamBuffer, &v, sizeof(int32_t));
                            }break;
                            case Brace::BRACE_DATA_TYPE_UINT32: {
                                uint32_t v = Brace::VarGetUInt32((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                FMemory::Memcpy(inParamBuffer, &v, sizeof(uint32_t));
                            }break;
                            case Brace::BRACE_DATA_TYPE_INT64: {
                                int64_t v = Brace::VarGetInt64((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                FMemory::Memcpy(inParamBuffer, &v, sizeof(int64_t));
                            }break;
                            case Brace::BRACE_DATA_TYPE_UINT64: {
                                uint64_t v = Brace::VarGetUInt64((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                FMemory::Memcpy(inParamBuffer, &v, sizeof(uint64_t));
                            }break;
                            case Brace::BRACE_DATA_TYPE_FLOAT: {
                                float v = Brace::VarGetFloat((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                FMemory::Memcpy(inParamBuffer, &v, sizeof(float));
                            }break;
                            case Brace::BRACE_DATA_TYPE_DOUBLE: {
                                double v = Brace::VarGetDouble((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                FMemory::Memcpy(inParamBuffer, &v, sizeof(double));
                            }break;
                            case Brace::BRACE_DATA_TYPE_STRING: {
                                auto& v = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                FMemory::Memcpy(inParamBuffer, v.c_str(), sizeof(const char*));
                            }break;
                            case Brace::BRACE_DATA_TYPE_OBJECT: {
                                auto& v = Brace::VarGetObject((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                switch (argInfo.ObjectTypeId) {
                                case CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT: {
                                    auto* p = static_cast<UObjectBraceObject*>(v.get());
                                    FMemory::Memcpy(inParamBuffer, p->GetImpl(), sizeof(UObject*));
                                }break;
                                default: {
                                    auto* pInfo = m_ArgObjInfos[argIndex];
                                    if (nullptr != pInfo && pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STRUCT) {
                                        argIsStruct = true;
                                        auto* p = static_cast<StructObj*>(v.get());
                                        if (nullptr != p) {
                                            int rsize = p->GetObjectInfo()->FieldTable.Size;
                                            FMemory::Memcpy(propBuffer, p->GetMemory(), (size <= rsize ? size : rsize));
                                        }
                                    }
                                }break;
                                }
                            }break;
                            }
                            if (!argIsStruct) {
                                FMemory::Memcpy(propBuffer, inParamBuffer, (size < sizeof(inParamBuffer) ? size : sizeof(inParamBuffer)));
                            }
                            ++argIndex;
                        }
                    }

                    pObj->ProcessEvent(pFunc, funcPramsBuffer);   //call function
                    uint8 outParamBuffer[8];
                    int outIndex = 0;
                    //copy back out params
                    for (TFieldIterator<FProperty> it(pFunc); it; ++it) {
                        FProperty* prop = *it;
                        if (prop->PropertyFlags & CPF_OutParm) {
                            int size = prop->GetSize();
                            void* propBuffer = prop->ContainerPtrToValuePtr<void*>(funcPramsBuffer);
                            if (outIndex == 0) {
                                FMemory::Memzero(outParamBuffer, sizeof(outParamBuffer));
                                FMemory::Memcpy(outParamBuffer, propBuffer, size < sizeof(outParamBuffer) ? size : sizeof(outParamBuffer));
                                switch (m_ResultInfo.Type) {
                                case Brace::BRACE_DATA_TYPE_BOOL: {
                                    bool v = *reinterpret_cast<bool*>(outParamBuffer);
                                    Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                                }break;
                                case Brace::BRACE_DATA_TYPE_INT8: {
                                    int8_t v = *reinterpret_cast<int8_t*>(outParamBuffer);
                                    Brace::VarSetInt8((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                                }break;
                                case Brace::BRACE_DATA_TYPE_UINT8: {
                                    uint8_t v = *reinterpret_cast<uint8_t*>(outParamBuffer);
                                    Brace::VarSetUInt8((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                                }break;
                                case Brace::BRACE_DATA_TYPE_INT16: {
                                    int16_t v = *reinterpret_cast<int16_t*>(outParamBuffer);
                                    Brace::VarSetInt16((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                                }break;
                                case Brace::BRACE_DATA_TYPE_UINT16: {
                                    uint16_t v = *reinterpret_cast<uint16_t*>(outParamBuffer);
                                    Brace::VarSetUInt16((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                                }break;
                                case Brace::BRACE_DATA_TYPE_INT32: {
                                    int32_t v = *reinterpret_cast<int32_t*>(outParamBuffer);
                                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                                }break;
                                case Brace::BRACE_DATA_TYPE_UINT32: {
                                    uint32_t v = *reinterpret_cast<uint32_t*>(outParamBuffer);
                                    Brace::VarSetUInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                                }break;
                                case Brace::BRACE_DATA_TYPE_INT64: {
                                    int64_t v = *reinterpret_cast<int64_t*>(outParamBuffer);
                                    Brace::VarSetInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                                }break;
                                case Brace::BRACE_DATA_TYPE_UINT64: {
                                    uint64_t v = *reinterpret_cast<uint64_t*>(outParamBuffer);
                                    Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                                }break;
                                case Brace::BRACE_DATA_TYPE_FLOAT: {
                                    float v = *reinterpret_cast<float*>(outParamBuffer);
                                    Brace::VarSetFloat((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                                }break;
                                case Brace::BRACE_DATA_TYPE_DOUBLE: {
                                    double v = *reinterpret_cast<double*>(outParamBuffer);
                                    Brace::VarSetDouble((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                                }break;
                                case Brace::BRACE_DATA_TYPE_STRING: {
                                    const char* v = *reinterpret_cast<const char**>(outParamBuffer);
                                    Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                                }break;
                                case Brace::BRACE_DATA_TYPE_OBJECT: {
                                    if (nullptr != m_ResultObjInfo && m_ResultObjInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STRUCT) {
                                        int rsize = m_ResultObjInfo->FieldTable.Size;
                                        StructObj* pStruct = new StructObj();
                                        pStruct->AllocMemory(m_ResultObjInfo);
                                        FMemory::Memcpy(pStruct->GetMemory(), propBuffer, static_cast<size_t>(size <= rsize ? size : rsize));
                                        std::shared_ptr<void> p(pStruct);
                                        Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, p);
                                    }
                                    else {
                                        switch (m_ResultInfo.ObjectTypeId) {
                                        case CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT: {
                                            UObject* v = *reinterpret_cast<UObject**>(outParamBuffer);
                                            std::shared_ptr<void> p(new UObjectBraceObject(v));
                                            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, p);
                                        }break;
                                        }
                                    }
                                }break;
                                }
                            }
                        }
                    }

                    //!!destructframe see also UObject::ProcessEvent
                    for (TFieldIterator<FProperty> it(pFunc); it && it->HasAnyPropertyFlags(CPF_Parm); ++it) {
                        it->DestroyValue_InContainer(funcPramsBuffer);
                    }
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    private:
        void DumpChain(FReferenceChainSearch::FReferenceChain* pChain)
        {
            if (pChain->Num()) {
                // Roots are at the end so iterate from the last to the first node
                for (int32 nodeIndex = pChain->Num() - 1; nodeIndex >= 0; --nodeIndex) {
                    UObject* pObj = pChain->GetNode(nodeIndex)->Object;
                    const FReferenceChainSearch::FNodeReferenceInfo& referenceInfo = pChain->GetReferenceInfo(nodeIndex);
                    std::stringstream ss;
                    ss << TCHAR_TO_UTF8(FCString::Spc(FMath::Min<int32>(TCStringSpcHelper<TCHAR>::MAX_SPACES, pChain->Num() - nodeIndex - 1)))
                        << GetObjectFlags(pObj)
                        << TCHAR_TO_UTF8(*pObj->GetFullName())
                        << TCHAR_TO_UTF8(*referenceInfo.ToString());
                    std::string str = ss.str();
                    LogInfo(str);
                    LogToDebug(UTF8_TO_TCHAR(str.c_str()));
                }
                LogInfo("  ");
                LogToDebug("  ");
            }
        }
    protected:
        UObjectMemberCallProvider(Brace::BraceScript& interpreter) :AbstractMemberCallApiProvider(interpreter), m_ObjInfo(), m_Obj(), m_ArgInfos(), m_Args(), m_ArgObjInfos(), m_ResultInfo(), m_ResultObjInfo(nullptr), m_Member(), m_ArgIteratorIndex(INVALID_INDEX)
        {}
    protected:
        Brace::OperandRuntimeInfo m_ObjInfo;
        Brace::BraceApiExecutor m_Obj;
        std::vector<Brace::OperandRuntimeInfo> m_ArgInfos;
        std::vector<Brace::BraceApiExecutor> m_Args;
        std::vector<BraceObjectInfo*> m_ArgObjInfos;
        Brace::OperandRuntimeInfo m_ResultInfo;
        BraceObjectInfo* m_ResultObjInfo;
        std::string m_Member;

        int m_ArgIteratorIndex;
    };
    class UObjectMemberSetProvider final : public AbstractMemberSetApiProvider
    {
        friend class MemberSetExp;
    protected:
        virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
        {
            if (member == "Name") {
                if (!Brace::IsStringType(argInfo.Type)) {
                    std::stringstream ss;
                    ss << "uobject.Name must assigned string value, line: " << data.GetLine();
                    LogError(ss.str());
                    executor = nullptr;
                    return false;
                }
                executor.attach(this, &UObjectMemberSetProvider::ExecuteSetName);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ArgInfo = argInfo;
                std::swap(m_Arg, arg);
                std::swap(m_Member, member);
                return true;
            }
            else if (member == "Outer") {
                if (!Brace::IsObjectType(argInfo.Type) || argInfo.ObjectTypeId != CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT) {
                    std::stringstream ss;
                    ss << "uobject.Outer must assigned uobject value, line: " << data.GetLine();
                    LogError(ss.str());
                    executor = nullptr;
                    return false;
                }
                executor.attach(this, &UObjectMemberSetProvider::ExecuteSetOuter);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ArgInfo = argInfo;
                std::swap(m_Arg, arg);
                std::swap(m_Member, member);
                return true;
            }
            else {
                //try call by reflection
                executor.attach(this, &UObjectMemberSetProvider::ExecuteReflection);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ArgInfo = argInfo;
                if (Brace::IsObjectType(argInfo.Type)) {
                    auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(argInfo.ObjectTypeId);
                    if (nullptr != pInfo) {
                        m_ArgIsStruct = (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STRUCT);
                    }
                }
                std::swap(m_Arg, arg);
                std::swap(m_Member, member);
                return true;
            }
        }
    private:
        int ExecuteSetName(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            if (!m_Arg.isNull())
                m_Arg(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                const std::string& str = Brace::VarGetString((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.VarIndex);
                if (nullptr != pObj) {
                    pObj->Rename(UTF8_TO_TCHAR(str.c_str()));
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteSetOuter(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            if (!m_Arg.isNull())
                m_Arg(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                if (nullptr != pObj) {
                    auto& argObjPtr = Brace::VarGetObject((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.VarIndex);
                    auto* argObj = static_cast<UObjectBraceObject*>(argObjPtr.get());
                    if (nullptr != argObj) {
                        UObject* pArgObj = argObj->GetImpl();
                        if (nullptr != pArgObj) {
                            pObj->Rename(nullptr, pArgObj);
                        }
                    }
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteReflection(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            if (!m_Arg.isNull())
                m_Arg(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                UClass* pClass = pObj->GetClass();
                FProperty* pProp = pClass->FindPropertyByName(FName(m_Member.c_str()));
                if (nullptr != pProp) {
                    uint8 inParamBuffer[8];
                    void* propBuffer = pProp->ContainerPtrToValuePtr<void*>(pObj);
                    FMemory::Memzero(inParamBuffer, sizeof(inParamBuffer));
                    auto& argInfo = m_ArgInfo;
                    switch (argInfo.Type) {
                    case Brace::BRACE_DATA_TYPE_BOOL: {
                        bool v = Brace::VarGetBool((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        FMemory::Memcpy(inParamBuffer, &v, sizeof(bool));
                    }break;
                    case Brace::BRACE_DATA_TYPE_INT8: {
                        int8_t v = Brace::VarGetInt8((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        FMemory::Memcpy(inParamBuffer, &v, sizeof(int8_t));
                    }break;
                    case Brace::BRACE_DATA_TYPE_UINT8: {
                        uint8_t v = Brace::VarGetUInt8((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        FMemory::Memcpy(inParamBuffer, &v, sizeof(uint8_t));
                    }break;
                    case Brace::BRACE_DATA_TYPE_INT16: {
                        int16_t v = Brace::VarGetInt16((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        FMemory::Memcpy(inParamBuffer, &v, sizeof(int16_t));
                    }break;
                    case Brace::BRACE_DATA_TYPE_UINT16: {
                        uint16_t v = Brace::VarGetUInt16((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        FMemory::Memcpy(inParamBuffer, &v, sizeof(uint16_t));
                    }break;
                    case Brace::BRACE_DATA_TYPE_INT32: {
                        int32_t v = Brace::VarGetInt32((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        FMemory::Memcpy(inParamBuffer, &v, sizeof(int32_t));
                    }break;
                    case Brace::BRACE_DATA_TYPE_UINT32: {
                        uint32_t v = Brace::VarGetUInt32((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        FMemory::Memcpy(inParamBuffer, &v, sizeof(uint32_t));
                    }break;
                    case Brace::BRACE_DATA_TYPE_INT64: {
                        int64_t v = Brace::VarGetInt64((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        FMemory::Memcpy(inParamBuffer, &v, sizeof(int64_t));
                    }break;
                    case Brace::BRACE_DATA_TYPE_UINT64: {
                        uint64_t v = Brace::VarGetUInt64((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        FMemory::Memcpy(inParamBuffer, &v, sizeof(uint64_t));
                    }break;
                    case Brace::BRACE_DATA_TYPE_FLOAT: {
                        float v = Brace::VarGetFloat((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        FMemory::Memcpy(inParamBuffer, &v, sizeof(float));
                    }break;
                    case Brace::BRACE_DATA_TYPE_DOUBLE: {
                        double v = Brace::VarGetDouble((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        FMemory::Memcpy(inParamBuffer, &v, sizeof(double));
                    }break;
                    case Brace::BRACE_DATA_TYPE_STRING: {
                        auto& v = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        FMemory::Memcpy(inParamBuffer, v.c_str(), sizeof(const char*));
                    }break;
                    case Brace::BRACE_DATA_TYPE_OBJECT: {
                        auto& v = Brace::VarGetObject((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        switch (argInfo.ObjectTypeId) {
                        case CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT: {
                            auto* p = static_cast<UObjectBraceObject*>(v.get());
                            if (nullptr != p) {
                                FMemory::Memcpy(inParamBuffer, p->GetImpl(), sizeof(UObject*));
                            }
                        }break;
                        }
                    }break;
                    }
                    int size = pProp->GetSize();
                    if (m_ArgIsStruct) {
                        auto& v = Brace::VarGetObject((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        auto* p = static_cast<StructObj*>(v.get());
                        if (nullptr != p) {
                            int rsize = p->GetObjectInfo()->FieldTable.Size;
                            FMemory::Memcpy(propBuffer, p->GetMemory(), (size <= rsize ? size : rsize));
                        }
                    }
                    else {
                        FMemory::Memcpy(propBuffer, inParamBuffer, (size < sizeof(inParamBuffer) ? size : sizeof(inParamBuffer)));
                    }
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    protected:
        UObjectMemberSetProvider(Brace::BraceScript& interpreter) :AbstractMemberSetApiProvider(interpreter), m_ObjInfo(), m_Obj(), m_ArgInfo(), m_Arg(), m_ArgIsStruct(false), m_Member()
        {}
    protected:
        Brace::OperandRuntimeInfo m_ObjInfo;
        Brace::BraceApiExecutor m_Obj;
        Brace::OperandRuntimeInfo m_ArgInfo;
        Brace::BraceApiExecutor m_Arg;
        bool m_ArgIsStruct;
        std::string m_Member;
    };
    class UObjectMemberGetProvider final : public AbstractMemberGetApiProvider
    {
        friend class MemberGetExp;
    protected:
        virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
        {
            if (member == "Name") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetName);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "ClassName") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetClassName);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "Desc") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetDesc);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "FullName") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetFullName);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "GroupName") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetGroupName);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "PathName") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetPathName);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "FolderName") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetFolderName);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "ActorLabel") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetActorLabel);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "AssetId") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetAssetId);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "UniqueId") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_INT32;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetUniqueId);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "MemAddr") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT64;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetMemoryAddr);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "NumMem") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT64;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetNumMemory);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "MaxMem") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT64;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetMaxMemory);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "SysResMem") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT64;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetSystemResMemory);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "VideoResMem") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT64;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetVideoResMemory);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "SysSharedResMem") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT64;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetSystemSharedResMemory);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "VideoSharedResMem") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT64;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetVideoSharedResMemory);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "UnknownResMem") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT64;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetUnknownResMemory);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "TotalResMem") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT64;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetTotalResMemory);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "Package") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetPackage);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "PackageFileSize") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT64;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetPackageFileSize);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "PackageFileName") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetPackageFileName);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "PackagePersistentGuidStr") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &UObjectMemberGetProvider::ExecuteGetPackagePersistentGuidStr);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else {
                //try call by reflection
                if (resultInfo.Type != Brace::BRACE_DATA_TYPE_UNKNOWN) {
                    if (resultInfo.VarIndex == INVALID_INDEX) {
                        resultInfo.IsGlobal = false;
                        resultInfo.Name = GenTempVarName();
                        resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                        m_ResultInfo = resultInfo;
                    }
                    if (Brace::IsObjectType(resultInfo.Type)) {
                        m_ResultObjInfo = g_ObjectInfoMgr.GetBraceObjectInfo(resultInfo.ObjectTypeId);
                    }
                }
                executor.attach(this, &UObjectMemberGetProvider::ExecuteReflection);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                std::swap(m_Member, member);
                return true;
            }
        }
    private:
        int ExecuteGetName(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                const UObject* pObj = scpObj->GetImpl();
                FString name = pObj->GetName();
                Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::string(TCHAR_TO_UTF8(*name)));
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetClassName(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                const UObject* pObj = scpObj->GetImpl();
                FString name = pObj->GetClass()->GetName();
                Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::string(TCHAR_TO_UTF8(*name)));
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetDesc(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                std::string fname = CalcObjDesc(pObj);
                Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::move(fname));
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetFullName(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                std::string fname = TCHAR_TO_UTF8(*pObj->GetFullName());
                Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::move(fname));
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetGroupName(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                std::string fname = TCHAR_TO_UTF8(*pObj->GetFullGroupName(false));
                Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::move(fname));
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetPathName(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                std::string fname = TCHAR_TO_UTF8(*pObj->GetPathName());
                Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::move(fname));
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetFolderName(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                AActor* pActor = Cast<AActor>(pObj);
                if (nullptr != pActor) {
#if UE_EDITOR
                    std::string fname = TCHAR_TO_UTF8(*pActor->GetFolderPath().ToString());
#else
                    std::string fname = "GetFolderName only be used in Editor";
#endif
                    Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::move(fname));
                }
                else {
                    Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::string());
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetActorLabel(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                AActor* pActor = Cast<AActor>(pObj);
                if (nullptr != pActor) {
#if UE_EDITOR
                    std::string fname = TCHAR_TO_UTF8(*pActor->GetActorLabel());
#else
                    std::string fname = "GetActorLabel only be used in Editor";
#endif
                    Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::move(fname));
                }
                else {
                    Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::string());
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetAssetId(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                std::string fname = TCHAR_TO_UTF8(*pObj->GetPrimaryAssetId().ToString());
                Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::move(fname));
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetUniqueId(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                int32_t id = pObj->GetUniqueID();
                Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, id);
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetMemoryAddr(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                const UObject* pObj = scpObj->GetImpl();
                Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, reinterpret_cast<uint64_t>(pObj));
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetNumMemory(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj && scpObj->GetImpl()) {
                auto* pMemSize = scpObj->GetOrCalcMemorySize();
                Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, pMemSize->GetNum());
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetMaxMemory(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj && scpObj->GetImpl()) {
                auto* pMemSize = scpObj->GetOrCalcMemorySize();
                Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, pMemSize->GetMax());
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetSystemResMemory(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj && scpObj->GetImpl()) {
                auto* pMemSize = scpObj->GetOrCalcMemorySize();
                Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, pMemSize->GetSysRes());
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetVideoResMemory(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj && scpObj->GetImpl()) {
                auto* pMemSize = scpObj->GetOrCalcMemorySize();
                Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, pMemSize->GetVideoRes());
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetSystemSharedResMemory(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj && scpObj->GetImpl()) {
                auto* pMemSize = scpObj->GetOrCalcMemorySize();
                Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, pMemSize->GetSysSharedRes());
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetVideoSharedResMemory(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj && scpObj->GetImpl()) {
                auto* pMemSize = scpObj->GetOrCalcMemorySize();
                Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, pMemSize->GetVideoSharedRes());
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetUnknownResMemory(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj && scpObj->GetImpl()) {
                auto* pMemSize = scpObj->GetOrCalcMemorySize();
                Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, pMemSize->GetUnknownRes());
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetTotalResMemory(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj && scpObj->GetImpl()) {
                auto* pMemSize = scpObj->GetOrCalcMemorySize();
                Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, pMemSize->GetTotalRes());
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetPackage(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj && scpObj->GetImpl()) {
                UObject* pObj = scpObj->GetImpl();
                uint64_t size = 0;
                UPackage* pPackage = pObj->GetPackage();
                if (nullptr != pPackage) {
                    Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(new UObjectBraceObject(pPackage)));
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetPackageFileSize(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj && scpObj->GetImpl()) {
                UObject* pObj = scpObj->GetImpl();
                uint64_t size = 0;
                UPackage* pPackage = pObj->GetPackage();
                if (nullptr != pPackage) {
                    size = pPackage->FileSize;
                }
                Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, size);
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetPackageFileName(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj && scpObj->GetImpl()) {
                UObject* pObj = scpObj->GetImpl();
                std::string str{};
                UPackage* pPackage = pObj->GetPackage();
                if (nullptr != pPackage) {
                    str = TCHAR_TO_UTF8(*pPackage->FileName.ToString());
                }
                Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::move(str));
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetPackagePersistentGuidStr(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj && scpObj->GetImpl()) {
                UObject* pObj = scpObj->GetImpl();
                std::string str{};
                UPackage* pPackage = pObj->GetPackage();
                if (nullptr != pPackage) {
#if UE_EDITOR
                    str = TCHAR_TO_UTF8(*pPackage->GetPersistentGuid().ToString());
#else
                    str = "PersistentGuid only be used in Editor";
#endif
                }
                Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::move(str));
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteReflection(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* scpObj = static_cast<UObjectBraceObject*>(ptr.get());
            if (nullptr != scpObj) {
                UObject* pObj = scpObj->GetImpl();
                UClass* pClass = pObj->GetClass();
                FProperty* pProp = pClass->FindPropertyByName(FName(m_Member.c_str()));
                if (nullptr != pProp) {
                    uint8 outParamBuffer[8];
                    void* propBuffer = pProp->ContainerPtrToValuePtr<void*>(pObj);
                    int size = pProp->GetSize();
                    FMemory::Memzero(outParamBuffer, sizeof(outParamBuffer));
                    FMemory::Memcpy(outParamBuffer, propBuffer, static_cast<size_t>(size < sizeof(outParamBuffer) ? size : sizeof(outParamBuffer)));
                    switch (m_ResultInfo.Type) {
                    case Brace::BRACE_DATA_TYPE_BOOL: {
                        bool v = *reinterpret_cast<bool*>(outParamBuffer);
                        Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    }break;
                    case Brace::BRACE_DATA_TYPE_INT8: {
                        int8_t v = *reinterpret_cast<int8_t*>(outParamBuffer);
                        Brace::VarSetInt8((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    }break;
                    case Brace::BRACE_DATA_TYPE_UINT8: {
                        uint8_t v = *reinterpret_cast<uint8_t*>(outParamBuffer);
                        Brace::VarSetUInt8((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    }break;
                    case Brace::BRACE_DATA_TYPE_INT16: {
                        int16_t v = *reinterpret_cast<int16_t*>(outParamBuffer);
                        Brace::VarSetInt16((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    }break;
                    case Brace::BRACE_DATA_TYPE_UINT16: {
                        uint16_t v = *reinterpret_cast<uint16_t*>(outParamBuffer);
                        Brace::VarSetUInt16((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    }break;
                    case Brace::BRACE_DATA_TYPE_INT32: {
                        int32_t v = *reinterpret_cast<int32_t*>(outParamBuffer);
                        Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    }break;
                    case Brace::BRACE_DATA_TYPE_UINT32: {
                        uint32_t v = *reinterpret_cast<uint32_t*>(outParamBuffer);
                        Brace::VarSetUInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    }break;
                    case Brace::BRACE_DATA_TYPE_INT64: {
                        int64_t v = *reinterpret_cast<int64_t*>(outParamBuffer);
                        Brace::VarSetInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    }break;
                    case Brace::BRACE_DATA_TYPE_UINT64: {
                        uint64_t v = *reinterpret_cast<uint64_t*>(outParamBuffer);
                        Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    }break;
                    case Brace::BRACE_DATA_TYPE_FLOAT: {
                        float v = *reinterpret_cast<float*>(outParamBuffer);
                        Brace::VarSetFloat((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    }break;
                    case Brace::BRACE_DATA_TYPE_DOUBLE: {
                        double v = *reinterpret_cast<double*>(outParamBuffer);
                        Brace::VarSetDouble((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    }break;
                    case Brace::BRACE_DATA_TYPE_STRING: {
                        const char* v = *reinterpret_cast<const char**>(outParamBuffer);
                        Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    }break;
                    case Brace::BRACE_DATA_TYPE_OBJECT: {
                        if (nullptr != m_ResultObjInfo && m_ResultObjInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STRUCT) {
                            int rsize = m_ResultObjInfo->FieldTable.Size;
                            StructObj* pStruct = new StructObj();
                            pStruct->AllocMemory(m_ResultObjInfo);
                            FMemory::Memcpy(pStruct->GetMemory(), propBuffer, static_cast<size_t>(size <= rsize ? size : rsize));
                            std::shared_ptr<void> p(pStruct);
                            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, p);
                        }
                        else {
                            switch (m_ResultInfo.ObjectTypeId) {
                            case CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT: {
                                UObject* v = *reinterpret_cast<UObject**>(outParamBuffer);
                                std::shared_ptr<void> p(new UObjectBraceObject(v));
                                Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, p);
                            }break;
                            }
                        }
                    }break;
                    }
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    protected:
        UObjectMemberGetProvider(Brace::BraceScript& interpreter) :AbstractMemberGetApiProvider(interpreter), m_ObjInfo(), m_Obj(), m_ResultInfo(), m_ResultObjInfo(nullptr), m_Member()
        {}
    protected:
        Brace::OperandRuntimeInfo m_ObjInfo;
        Brace::BraceApiExecutor m_Obj;
        Brace::OperandRuntimeInfo m_ResultInfo;
        BraceObjectInfo* m_ResultObjInfo;
        std::string m_Member;
    };

    class StructMemberCallProvider final : public AbstractMemberCallApiProvider
    {
        friend class MemberCallExp;
    protected:
        virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
        {
            return false;
        }
    protected:
        StructMemberCallProvider(Brace::BraceScript& interpreter) :AbstractMemberCallApiProvider(interpreter), m_ObjInfo(), m_Obj(), m_ArgInfos(), m_Args(), m_ResultInfo(), m_Member()
        {}
    protected:
        Brace::OperandRuntimeInfo m_ObjInfo;
        Brace::BraceApiExecutor m_Obj;
        std::vector<Brace::OperandRuntimeInfo> m_ArgInfos;
        std::vector<Brace::BraceApiExecutor> m_Args;
        Brace::OperandRuntimeInfo m_ResultInfo;
        std::string m_Member;
    };
    class StructMemberSetProvider final : public AbstractMemberSetApiProvider
    {
        friend class MemberSetExp;
    protected:
        virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
        {
            auto& fields = braceObjInfo.FieldTable.Fields;
            auto it = std::find_if(fields.begin(), fields.end(), [&](auto& v) { return v.Name == member; });
            if (it != fields.end()) {
                if ((Brace::IsStringType(it->Type.Type) && Brace::IsStringType(argInfo.Type)) || (!Brace::IsStringType(it->Type.Type) && CanAssign(it->Type.Type, it->Type.ObjectTypeId, argInfo.Type, argInfo.ObjectTypeId))) {
                    m_ObjInfo = objInfo;
                    std::swap(m_Obj, obj);
                    m_ArgInfo = argInfo;
                    std::swap(m_Arg, arg);
                    m_FieldInfo = *it;
                    executor.attach(this, &StructMemberSetProvider::Execute);

                    return true;
                }
            }
            std::stringstream ss;
            ss << "struct member " << member << " set error, line: " << data.GetLine();
            LogError(ss.str());
            executor = nullptr;
            return false;
        }
    private:
        int Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            if (!m_Arg.isNull())
                m_Arg(gvars, lvars);
            auto& optr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* pObj = static_cast<StructObj*>(optr.get());
            if (nullptr != pObj) {
                char* p = reinterpret_cast<char*>(pObj->GetMemory());
                switch (m_FieldInfo.Type.Type) {
                case Brace::BRACE_DATA_TYPE_BOOL: {
                    bool v = Brace::VarGetBoolean((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.Type, m_ArgInfo.VarIndex);
                    *(p + m_FieldInfo.Offset) = (v ? 1 : 0);
                }break;
                case Brace::BRACE_DATA_TYPE_INT8: {
                    int8_t v = static_cast<int8_t>(Brace::VarGetI64((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.Type, m_ArgInfo.VarIndex));
                    *reinterpret_cast<int8_t*>(p + m_FieldInfo.Offset) = v;
                }break;
                case Brace::BRACE_DATA_TYPE_UINT8: {
                    uint8_t v = static_cast<uint8_t>(Brace::VarGetU64((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.Type, m_ArgInfo.VarIndex));
                    *reinterpret_cast<uint8_t*>(p + m_FieldInfo.Offset) = v;
                }break;
                case Brace::BRACE_DATA_TYPE_INT16: {
                    int16_t v = static_cast<int16_t>(Brace::VarGetI64((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.Type, m_ArgInfo.VarIndex));
                    *reinterpret_cast<int16_t*>(p + m_FieldInfo.Offset) = v;
                }break;
                case Brace::BRACE_DATA_TYPE_UINT16: {
                    uint16_t v = static_cast<uint16_t>(Brace::VarGetU64((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.Type, m_ArgInfo.VarIndex));
                    *reinterpret_cast<uint16_t*>(p + m_FieldInfo.Offset) = v;
                }break;
                case Brace::BRACE_DATA_TYPE_INT32: {
                    int32_t v = static_cast<int32_t>(Brace::VarGetI64((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.Type, m_ArgInfo.VarIndex));
                    *reinterpret_cast<int32_t*>(p + m_FieldInfo.Offset) = v;
                }break;
                case Brace::BRACE_DATA_TYPE_UINT32: {
                    uint32_t v = static_cast<uint32_t>(Brace::VarGetU64((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.Type, m_ArgInfo.VarIndex));
                    *reinterpret_cast<uint32_t*>(p + m_FieldInfo.Offset) = v;
                }break;
                case Brace::BRACE_DATA_TYPE_INT64: {
                    int64_t v = Brace::VarGetI64((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.Type, m_ArgInfo.VarIndex);
                    *reinterpret_cast<int64_t*>(p + m_FieldInfo.Offset) = v;
                }break;
                case Brace::BRACE_DATA_TYPE_UINT64: {
                    uint64_t v = Brace::VarGetU64((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.Type, m_ArgInfo.VarIndex);
                    *reinterpret_cast<uint64_t*>(p + m_FieldInfo.Offset) = v;
                }break;
                case Brace::BRACE_DATA_TYPE_FLOAT: {
                    float v = static_cast<float>(Brace::VarGetF64((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.Type, m_ArgInfo.VarIndex));
                    *reinterpret_cast<float*>(p + m_FieldInfo.Offset) = v;
                }break;
                case Brace::BRACE_DATA_TYPE_DOUBLE: {
                    double v = Brace::VarGetF64((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.Type, m_ArgInfo.VarIndex);
                    *reinterpret_cast<double*>(p + m_FieldInfo.Offset) = v;
                }break;
                case Brace::BRACE_DATA_TYPE_STRING: {
                    std::string sv = Brace::VarGetString((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.VarIndex);
                    char* v = nullptr;
                    if (m_FieldInfo.IsPtr) {
                        v = *reinterpret_cast<char**>(p + m_FieldInfo.Offset);
                    }
                    else {
                        v = reinterpret_cast<char*>(p + m_FieldInfo.Offset);
                    }
                    size_t size = sv.length();
                    if (size > static_cast<size_t>(m_FieldInfo.Size))
                        size = static_cast<size_t>(m_FieldInfo.Size);
                    std::strncpy(v, sv.c_str(), size);
                    std::string* pStr = pObj->GetCachedStrField(m_FieldInfo.Offset);
                    if (nullptr == pStr)
                        pObj->CacheStrField(m_FieldInfo.Offset, std::string(v, size));
                    else
                        pStr->assign(sv, size);
                }break;
                case Brace::BRACE_DATA_TYPE_OBJECT: {
                    auto& ptr = Brace::VarGetObject((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.VarIndex);
                    if (ptr.get()) {
                        auto* pFieldInfo = m_FieldInfo.BraceObjInfo;
                        if (nullptr != pFieldInfo) {
                            if (pFieldInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STRUCT) {
                                void* v = nullptr;
                                if (m_FieldInfo.IsPtr) {
                                    v = *reinterpret_cast<void**>(p + m_FieldInfo.Offset);
                                }
                                else {
                                    v = reinterpret_cast<void*>(p + m_FieldInfo.Offset);
                                }
                                StructObj* pSrc = static_cast<StructObj*>(ptr.get());
                                std::memcpy(v, pSrc->GetMemory(), m_FieldInfo.Size);
                                auto* pExists = pObj->GetCachedObjField(m_FieldInfo.Offset);
                                if (nullptr == pExists) {
                                    StructObj* pWrap = new StructObj();
                                    pWrap->SetMemory(pFieldInfo, v);
                                    std::shared_ptr<void> sptr(pWrap);
                                    pObj->CacheObjField(m_FieldInfo.Offset, sptr);
                                }
                            }
                        }
                    }
                }break;
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    protected:
        StructMemberSetProvider(Brace::BraceScript& interpreter) :AbstractMemberSetApiProvider(interpreter), m_ObjInfo(), m_Obj(), m_ArgInfo(), m_Arg(), m_FieldInfo()
        {}
    protected:
        Brace::OperandRuntimeInfo m_ObjInfo;
        Brace::BraceApiExecutor m_Obj;
        Brace::OperandRuntimeInfo m_ArgInfo;
        Brace::BraceApiExecutor m_Arg;
        FieldInfo m_FieldInfo;
    };
    class StructMemberGetProvider final : public AbstractMemberGetApiProvider
    {
        friend class MemberGetExp;
    protected:
        virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
        {
            if (member == "StructName") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &StructMemberGetProvider::ExecuteGetStructName);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else if (member == "MemAddr") {
                resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT64;
                resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                resultInfo.IsGlobal = false;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                executor.attach(this, &StructMemberGetProvider::ExecuteGetMemoryAddr);

                m_ObjInfo = objInfo;
                std::swap(m_Obj, obj);
                m_ResultInfo = resultInfo;
                return true;
            }
            else {
                auto& fields = braceObjInfo.FieldTable.Fields;
                auto it = std::find_if(fields.begin(), fields.end(), [&](auto& v) { return v.Name == member; });
                if (it != fields.end()) {
                    resultInfo.Type = it->Type.Type;
                    resultInfo.ObjectTypeId = it->Type.ObjectTypeId;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);

                    m_ObjInfo = objInfo;
                    std::swap(m_Obj, obj);
                    m_FieldInfo = *it;
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &StructMemberGetProvider::Execute);

                    return true;
                }
            }
            std::stringstream ss;
            ss << "struct member " << member << " get error, line: " << data.GetLine();
            LogError(ss.str());
            executor = nullptr;
            return false;
        }
    private:
        int ExecuteGetStructName(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* pObj = static_cast<StructObj*>(ptr.get());
            if (nullptr != pObj) {
                auto* pInfo = pObj->GetObjectInfo();
                if (nullptr != pInfo) {
                    Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, pInfo->TypeName);
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteGetMemoryAddr(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& ptr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* pObj = static_cast<StructObj*>(ptr.get());
            if (nullptr != pObj) {
                Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, reinterpret_cast<uint64_t>(pObj));
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& optr = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            auto* pObj = static_cast<StructObj*>(optr.get());
            if (nullptr != pObj) {
                char* p = reinterpret_cast<char*>(pObj->GetMemory());
                switch (m_FieldInfo.Type.Type) {
                case Brace::BRACE_DATA_TYPE_BOOL: {
                    bool v = *(p + m_FieldInfo.Offset) != 0;
                    Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }break;
                case Brace::BRACE_DATA_TYPE_INT8: {
                    int8_t v = *reinterpret_cast<int8_t*>(p + m_FieldInfo.Offset);
                    Brace::VarSetInt8((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }break;
                case Brace::BRACE_DATA_TYPE_UINT8: {
                    uint8_t v = *reinterpret_cast<uint8_t*>(p + m_FieldInfo.Offset);
                    Brace::VarSetUInt8((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }break;
                case Brace::BRACE_DATA_TYPE_INT16: {
                    int16_t v = *reinterpret_cast<int16_t*>(p + m_FieldInfo.Offset);
                    Brace::VarSetInt16((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }break;
                case Brace::BRACE_DATA_TYPE_UINT16: {
                    uint16_t v = *reinterpret_cast<uint16_t*>(p + m_FieldInfo.Offset);
                    Brace::VarSetUInt16((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }break;
                case Brace::BRACE_DATA_TYPE_INT32: {
                    int32_t v = *reinterpret_cast<int32_t*>(p + m_FieldInfo.Offset);
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }break;
                case Brace::BRACE_DATA_TYPE_UINT32: {
                    uint32_t v = *reinterpret_cast<uint32_t*>(p + m_FieldInfo.Offset);
                    Brace::VarSetUInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }break;
                case Brace::BRACE_DATA_TYPE_INT64: {
                    int64_t v = *reinterpret_cast<int64_t*>(p + m_FieldInfo.Offset);
                    Brace::VarSetInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }break;
                case Brace::BRACE_DATA_TYPE_UINT64: {
                    uint64_t v = *reinterpret_cast<uint64_t*>(p + m_FieldInfo.Offset);
                    Brace::VarSetUInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }break;
                case Brace::BRACE_DATA_TYPE_FLOAT: {
                    float v = *reinterpret_cast<float*>(p + m_FieldInfo.Offset);
                    Brace::VarSetFloat((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }break;
                case Brace::BRACE_DATA_TYPE_DOUBLE: {
                    double v = *reinterpret_cast<double*>(p + m_FieldInfo.Offset);
                    Brace::VarSetDouble((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }break;
                case Brace::BRACE_DATA_TYPE_STRING: {
                    auto* ptr = pObj->GetCachedStrField(m_FieldInfo.Offset);
                    if (ptr) {
                        Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, *ptr);
                    }
                    else {
                        const char* v = nullptr;
                        if (m_FieldInfo.IsPtr) {
                            v = *reinterpret_cast<const char**>(p + m_FieldInfo.Offset);
                        }
                        else {
                            v = reinterpret_cast<const char*>(p + m_FieldInfo.Offset);
                        }
                        std::string str(v, m_FieldInfo.Size);
                        Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, str);
                    }
                }break;
                case Brace::BRACE_DATA_TYPE_OBJECT: {
                    auto* ptr = pObj->GetCachedObjField(m_FieldInfo.Offset);
                    if (ptr) {
                        Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, *ptr);
                    }
                    else {
                        auto* pFieldInfo = m_FieldInfo.BraceObjInfo;
                        if (nullptr != pFieldInfo) {
                            if (pFieldInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STRUCT) {
                                void* v = nullptr;
                                if (m_FieldInfo.IsPtr) {
                                    v = *reinterpret_cast<void**>(p + m_FieldInfo.Offset);
                                }
                                else {
                                    v = reinterpret_cast<void*>(p + m_FieldInfo.Offset);
                                }
                                StructObj* pWrap = new StructObj();
                                pWrap->SetMemory(pFieldInfo, v);
                                std::shared_ptr<void> sptr(pWrap);
                                pObj->CacheObjField(m_FieldInfo.Offset, sptr);
                                Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, sptr);
                            }
                        }
                    }
                }break;
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    protected:
        StructMemberGetProvider(Brace::BraceScript& interpreter) :AbstractMemberGetApiProvider(interpreter), m_ObjInfo(), m_Obj(), m_ResultInfo(), m_FieldInfo()
        {}
    protected:
        Brace::OperandRuntimeInfo m_ObjInfo;
        Brace::BraceApiExecutor m_Obj;
        Brace::OperandRuntimeInfo m_ResultInfo;
        FieldInfo m_FieldInfo;
    };

    class StructExp final : public Brace::AbstractBraceApi
    {
    public:
        StructExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            //struct(name){ a : int32; b : int32; ... };
            if (data.IsHighOrder()) {
                bool ret = true;
                auto& callData = data.GetLowerOrderFunction();
                const std::string& name = callData.GetParamId(0);
                int structId = g_ObjectInfoMgr.GetObjectTypeId(name);
                if (structId == Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN) {
                    structId = g_ObjectInfoMgr.AddNewObjectTypeId(name);
                }
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(structId);
                if (nullptr == pInfo) {
                    pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(structId, BRACE_OBJECT_CATEGORY_STRUCT, name);
                }
                auto& fieldTable = pInfo->FieldTable;
                fieldTable.Size = 0;
                fieldTable.Fields.clear();
                for (int ix = 0; ix < data.GetParamNum(); ++ix) {
                    auto* pSyntax = data.GetParam(ix);
                    if (pSyntax->GetSyntaxType() == DslData::ISyntaxComponent::TYPE_FUNCTION && pSyntax->GetId() == ":") {
                        auto& funcData = *static_cast<DslData::FunctionData*>(pSyntax);
                        if (funcData.GetParamNum() == 2) {
                            const std::string& fname = funcData.GetParamId(0);
                            const std::string& typeId = funcData.GetParamId(1);
                            int paramSyntaxType = funcData.GetParam(0)->GetSyntaxType();
                            if (paramSyntaxType == DslData::ISyntaxComponent::TYPE_FUNCTION && (typeId == "chararray" || typeId == "chararrayptr")) {
                                auto* paramFuncData = static_cast<DslData::FunctionData*>(funcData.GetParam(1));
                                int size = std::stoi(paramFuncData->GetParamId(0), nullptr, 0);
                                FieldInfo fi{};
                                fi.Name = fname;
                                fi.IsPtr = typeId == "chararrayptr";
                                fi.Type.Type = Brace::BRACE_DATA_TYPE_STRING;
                                fi.Type.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                                fi.Offset = fieldTable.Size;
                                fi.Size = size;
                                fieldTable.Size += (fi.IsPtr ? static_cast<int>(sizeof(void*)) : fi.Size);
                                fieldTable.Fields.push_back(std::move(fi));
                            }
                            else {
                                auto tinfo = ParseParamTypeInfo(*funcData.GetParam(1));
                                FieldInfo fi{};
                                fi.Name = fname;
                                fi.IsPtr = tinfo.IsRef;
                                fi.Type.Type = tinfo.Type;
                                fi.Type.ObjectTypeId = tinfo.ObjectTypeId;
                                fi.Offset = fieldTable.Size;
                                if (!tinfo.IsRef && tinfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
                                    auto* pFieldTypeInfo = g_ObjectInfoMgr.GetBraceObjectInfo(tinfo.ObjectTypeId);
                                    fi.BraceObjInfo = pFieldTypeInfo;
                                    if (nullptr != pFieldTypeInfo && pFieldTypeInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STRUCT) {
                                        fi.Size = pFieldTypeInfo->FieldTable.Size;
                                    }
                                    else {
                                        ret = false;
                                    }
                                }
                                else {
                                    fi.Size = (tinfo.IsRef ? static_cast<int>(sizeof(void*)) : Brace::GetDataTypeSize(tinfo.Type));
                                }
                                fieldTable.Size += fi.Size;
                                fieldTable.Fields.push_back(std::move(fi));
                            }
                        }
                    }
                }
                executor = nullptr;
                return ret;
            }
            std::stringstream ss;
            ss << "Illegal struct syntax, line: " << data.GetLine();
            LogError(ss.str());
            executor = nullptr;
            return false;
        }
    };
    class NewStructExp final : public Brace::AbstractBraceApi
    {
    public:
        NewStructExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_pObjectInfo(nullptr)
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& funcData, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            if (funcData.GetParamNum() == 1) {
                const std::string& id = funcData.GetParamId(0);
                int objTypeId = g_ObjectInfoMgr.GetObjectTypeId(id);
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
                if (nullptr != pInfo && pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STRUCT) {
                    m_pObjectInfo = pInfo;
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                    resultInfo.ObjectTypeId = objTypeId;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;

                    executor.attach(this, &NewStructExp::Execute);
                    return true;
                }
            }
            //error
            std::stringstream ss;
            ss << "BraceScript error, " << funcData.GetId() << " line " << funcData.GetLine();
            LogError(ss.str());
            return false;
        }
    private:
        int Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            auto* pObj = new StructObj();
            pObj->AllocMemory(m_pObjectInfo);
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(pObj));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    private:
        const BraceObjectInfo* m_pObjectInfo;
        Brace::OperandRuntimeInfo m_ResultInfo;
    };
    class ReInterpretAsExp final : public Brace::AbstractBraceApi
    {
    public:
        ReInterpretAsExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_pObjectInfo(nullptr)
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& funcData, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            if (funcData.GetParamNum() == 2) {
                const std::string& id = funcData.GetParamId(1);
                int objTypeId = g_ObjectInfoMgr.GetObjectTypeId(id);
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
                if (nullptr != pInfo && pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STRUCT) {
                    Brace::OperandLoadtimeInfo argInfo;
                    m_Arg = LoadHelper(*funcData.GetParam(0), argInfo);
                    m_ArgInfo = argInfo;
                    if (Brace::IsSignedType(argInfo.Type) || Brace::IsUnsignedType(argInfo.Type)) {
                        m_pObjectInfo = pInfo;
                        resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                        resultInfo.ObjectTypeId = objTypeId;
                        resultInfo.Name = GenTempVarName();
                        resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                        m_ResultInfo = resultInfo;

                        executor.attach(this, &ReInterpretAsExp::Execute);
                        return true;
                    }
                }
            }
            //error
            std::stringstream ss;
            ss << "BraceScript error, " << funcData.GetId() << " line " << funcData.GetLine();
            LogError(ss.str());
            return false;
        }
    private:
        int Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Arg.isNull())
                m_Arg(gvars, lvars);
            uint64_t v = Brace::VarGetU64((m_ArgInfo.IsGlobal ? gvars : lvars), m_ArgInfo.Type, m_ArgInfo.VarIndex);
            auto* pObj = new StructObj();
            pObj->SetMemory(m_pObjectInfo, reinterpret_cast<void*>(v));
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(pObj));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    private:
        Brace::OperandRuntimeInfo m_ArgInfo;
        Brace::BraceApiExecutor m_Arg;
        const BraceObjectInfo* m_pObjectInfo;
        Brace::OperandRuntimeInfo m_ResultInfo;
    };

    /// Internally fixed collection objects use switch-case rather than virtual-function-dispatch, simply because switch-case may require less code.
    /// and virtual-function-dispatch must define one class for each API, and dozens may be required.
    class ArrayHashtableMemberCallProvider final : public AbstractMemberCallApiProvider
    {
        friend class MemberCallExp;
    protected:
        virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            int num = data.GetParamNum();
            if (num < 2)
                return false;
            std::swap(m_Obj, obj);
            m_ObjInfo = objInfo;
            std::swap(m_Member, member);
            std::swap(m_Args, args);
            Brace::OperandLoadtimeInfo firstArgInfo;
            bool first = true;
            for (auto& argInfo : argInfos) {
                m_ArgInfos.push_back(argInfo);
                if (first) {
                    first = false;
                    firstArgInfo = std::move(argInfo);
                }
            }
            bool isArray = false;
            bool isHashtable = false;
            bool isIntKey = true;
            int dataType = Brace::BRACE_DATA_TYPE_OBJECT;
            int objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
            switch (objInfo.ObjectTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY:
                isArray = true;
                dataType = Brace::BRACE_DATA_TYPE_STRING;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY:
                isArray = true;
                dataType = Brace::BRACE_DATA_TYPE_INT64;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY:
                isArray = true;
                dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY:
                isArray = true;
                dataType = Brace::BRACE_DATA_TYPE_BOOL;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                dataType = Brace::BRACE_DATA_TYPE_STRING;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                dataType = Brace::BRACE_DATA_TYPE_INT64;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                dataType = Brace::BRACE_DATA_TYPE_BOOL;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE:
                isHashtable = true;
                dataType = Brace::BRACE_DATA_TYPE_STRING;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE:
                isHashtable = true;
                dataType = Brace::BRACE_DATA_TYPE_INT64;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE:
                isHashtable = true;
                dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE:
                isHashtable = true;
                dataType = Brace::BRACE_DATA_TYPE_BOOL;
                break;
            }
            switch (braceObjInfo.ObjectCategory) {
            case BRACE_OBJECT_CATEGORY_OBJ_ARRAY:
                isArray = true;
                objTypeId = braceObjInfo.GetTypeParamObjTypeId(0);
                break;
            case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE:
                isHashtable = true;
                objTypeId = braceObjInfo.GetTypeParamObjTypeId(1);
                break;
            case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                objTypeId = braceObjInfo.GetTypeParamObjTypeId(1);
                break;
            }
            if (isArray) {
                if (m_Member == "resize") {
                    bool good = false;
                    if (m_ArgInfos.size() == 1) {
                        auto& argInfo = m_ArgInfos[0];
                        if (argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                            good = true;
                        }
                    }
                    if (good) {
                        resultInfo = Brace::OperandLoadtimeInfo();
                        m_ResultInfo = resultInfo;
                        executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayResize);
                        return true;
                    }
                    else {
                        std::stringstream ss;
                        ss << "Array.resize's param dismatch, line: " << data.GetLine();
                        LogError(ss.str());
                        executor = nullptr;
                        return false;
                    }
                }
                else if (m_Member == "push") {
                    bool good = false;
                    if (m_ArgInfos.size() == 1) {
                        if (CanAssign(dataType, objTypeId, firstArgInfo.Type, firstArgInfo.ObjectTypeId)) {
                            good = true;
                        }
                    }
                    if (good) {
                        resultInfo = Brace::OperandLoadtimeInfo();
                        m_ResultInfo = resultInfo;
                        executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayPush);
                        return true;
                    }
                    else {
                        std::stringstream ss;
                        ss << "Array.push's param dismatch, line: " << data.GetLine();
                        LogError(ss.str());
                        executor = nullptr;
                        return false;
                    }
                }
                else if (m_Member == "pop") {
                    resultInfo.Type = dataType;
                    resultInfo.ObjectTypeId = objTypeId;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayPop);
                    return true;
                }
                else if (m_Member == "insert") {
                    bool good = false;
                    if (m_ArgInfos.size() == 2) {
                        auto& keyArgInfo = m_ArgInfos[0];
                        auto& valArgInfo = m_ArgInfos[1];
                        if (keyArgInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && keyArgInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                            if (CanAssign(dataType, objTypeId, valArgInfo.Type, valArgInfo.ObjectTypeId)) {
                                good = true;
                            }
                        }
                    }
                    if (good) {
                        resultInfo = Brace::OperandLoadtimeInfo();
                        m_ResultInfo = resultInfo;
                        executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayInsert);
                        return true;
                    }
                    else {
                        std::stringstream ss;
                        ss << "Array.insert's param dismatch, line: " << data.GetLine();
                        LogError(ss.str());
                        executor = nullptr;
                        return false;
                    }
                }
                else if (m_Member == "remove") {
                    bool good = false;
                    if (m_ArgInfos.size() == 1) {
                        auto& argInfo = m_ArgInfos[0];
                        if (argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                            good = true;
                        }
                    }
                    if (good) {
                        resultInfo = Brace::OperandLoadtimeInfo();
                        m_ResultInfo = resultInfo;
                        executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayRemove);
                        return true;
                    }
                    else {
                        std::stringstream ss;
                        ss << "Array.remove's param dismatch, line: " << data.GetLine();
                        LogError(ss.str());
                        executor = nullptr;
                        return false;
                    }
                }
                else if (m_Member == "clear") {
                    resultInfo = Brace::OperandLoadtimeInfo();
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayClear);
                    return true;
                }
            }
            else if (isHashtable) {
                if (m_Member == "contains") {
                    bool good = false;
                    if (m_ArgInfos.size() == 1) {
                        auto& argInfo = m_ArgInfos[0];
                        if ((isIntKey && argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) ||
                            (!isIntKey && argInfo.Type == Brace::BRACE_DATA_TYPE_STRING)) {
                            good = true;
                        }
                    }
                    if (good) {
                        resultInfo.Type = Brace::BRACE_DATA_TYPE_BOOL;
                        resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                        resultInfo.Name = GenTempVarName();
                        resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                        m_ResultInfo = resultInfo;
                        executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteHashtableContains);
                        return true;
                    }
                    else {
                        std::stringstream ss;
                        ss << "Hashtable.contains's param dismatch, line: " << data.GetLine();
                        LogError(ss.str());
                        executor = nullptr;
                        return false;
                    }
                }
                else if (m_Member == "add") {
                    bool good = false;
                    if (m_ArgInfos.size() == 2) {
                        auto& keyArgInfo = m_ArgInfos[0];
                        auto& valArgInfo = m_ArgInfos[1];
                        if ((isIntKey && keyArgInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && keyArgInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) ||
                            (!isIntKey && keyArgInfo.Type == Brace::BRACE_DATA_TYPE_STRING)) {
                            if (CanAssign(dataType, objTypeId, valArgInfo.Type, valArgInfo.ObjectTypeId)) {
                                good = true;
                            }
                        }
                    }
                    if (good) {
                        resultInfo = Brace::OperandLoadtimeInfo();
                        m_ResultInfo = resultInfo;
                        executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteHashtableAdd);
                        return true;
                    }
                    else {
                        std::stringstream ss;
                        ss << "Hashtable.add's param dismatch, line: " << data.GetLine();
                        LogError(ss.str());
                        executor = nullptr;
                        return false;
                    }
                }
                else if (m_Member == "remove") {
                    bool good = false;
                    if (m_ArgInfos.size() == 1) {
                        auto& argInfo = m_ArgInfos[0];
                        if ((isIntKey && argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) ||
                            (!isIntKey && argInfo.Type == Brace::BRACE_DATA_TYPE_STRING)) {
                            good = true;
                        }
                    }
                    if (good) {
                        resultInfo = Brace::OperandLoadtimeInfo();
                        m_ResultInfo = resultInfo;
                        executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteHashtableRemove);
                        return true;
                    }
                    else {
                        std::stringstream ss;
                        ss << "Hashtable.remove's param dismatch, line: " << data.GetLine();
                        LogError(ss.str());
                        executor = nullptr;
                        return false;
                    }
                }
                else if (m_Member == "clear") {
                    resultInfo = Brace::OperandLoadtimeInfo();
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteHashtableClear);
                    return true;
                }
            }
            std::stringstream ss;
            ss << "Unknown member " << m_Member << " line: " << data.GetLine();
            LogError(ss.str());
            executor = nullptr;
            return false;
        }
    private:
        int ExecuteArrayResize(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            for (auto&& _arg : m_Args) {
                if (!_arg.isNull())
                    _arg(gvars, lvars);
            }
            auto& arr = m_ObjInfo;
            auto& arg = m_ArgInfos[0];
            const std::shared_ptr<void>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
            switch (arr.ObjectTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<bool>*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    pArr->resize(varg);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<int64_t>*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    pArr->resize(varg);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<double>*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    pArr->resize(varg);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<std::string>*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    pArr->resize(varg);
                }
            }break;
            default: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ObjectArray*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    pArr->resize(varg);
                }
            }break;
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteArrayPush(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            for (auto&& _arg : m_Args) {
                if (!_arg.isNull())
                    _arg(gvars, lvars);
            }
            auto& arr = m_ObjInfo;
            auto& arg = m_ArgInfos[0];
            const std::shared_ptr<void>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
            switch (arr.ObjectTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<bool>*>(ptr);
                    bool varg = Brace::VarGetBoolean((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    pArr->push_back(varg);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<int64_t>*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    pArr->push_back(varg);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<double>*>(ptr);
                    double varg = Brace::VarGetF64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    pArr->push_back(varg);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<std::string>*>(ptr);
                    std::string varg = Brace::VarGetStr((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    pArr->push_back(std::move(varg));
                }
            }break;
            default: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ObjectArray*>(ptr);
                    auto varg = Brace::VarGetObject((arg.IsGlobal ? gvars : lvars), arg.VarIndex);
                    pArr->push_back(varg);
                }
            }break;
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteArrayPop(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& arr = m_ObjInfo;
            const std::shared_ptr<void>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
            switch (arr.ObjectTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<bool>*>(ptr);
                    bool v = pArr->back();
                    Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    pArr->pop_back();
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<int64_t>*>(ptr);
                    int64_t v = pArr->back();
                    Brace::VarSetInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    pArr->pop_back();
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<double>*>(ptr);
                    double v = pArr->back();
                    Brace::VarSetDouble((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    pArr->pop_back();
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<std::string>*>(ptr);
                    const std::string& v = pArr->back();
                    Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    pArr->pop_back();
                }
            }break;
            default: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ObjectArray*>(ptr);
                    auto v = pArr->back();
                    Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                    pArr->pop_back();
                }
            }break;
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteArrayInsert(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            for (auto&& _arg : m_Args) {
                if (!_arg.isNull())
                    _arg(gvars, lvars);
            }
            auto& arr = m_ObjInfo;
            auto& arg = m_ArgInfos[0];
            auto& val = m_ArgInfos[1];
            const std::shared_ptr<void>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
            switch (arr.ObjectTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<bool>*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    bool v = Brace::VarGetBoolean((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                    VectorInsert((*pArr), varg, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<int64_t>*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    int64_t v = Brace::VarGetI64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                    VectorInsert((*pArr), varg, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<double>*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    double v = Brace::VarGetF64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                    VectorInsert((*pArr), varg, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<std::string>*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    std::string v = Brace::VarGetStr((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                    VectorInsert((*pArr), varg, std::move(v));
                }
            }break;
            default: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ObjectArray*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    auto v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
                    VectorInsert((*pArr), varg, v);
                }
            }break;
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteArrayRemove(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            for (auto&& _arg : m_Args) {
                if (!_arg.isNull())
                    _arg(gvars, lvars);
            }
            auto& arr = m_ObjInfo;
            auto& arg = m_ArgInfos[0];
            const std::shared_ptr<void>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
            switch (arr.ObjectTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<bool>*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    VectorErase((*pArr), varg);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<int64_t>*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    VectorErase((*pArr), varg);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<double>*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    VectorErase((*pArr), varg);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<std::string>*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    VectorErase((*pArr), varg);
                }
            }break;
            default: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ObjectArray*>(ptr);
                    int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
                    VectorErase((*pArr), varg);
                }
            }break;
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteArrayClear(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& arr = m_ObjInfo;
            const std::shared_ptr<void>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
            switch (arr.ObjectTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<bool>*>(ptr);
                    pArr->clear();
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<int64_t>*>(ptr);
                    pArr->clear();
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<double>*>(ptr);
                    pArr->clear();
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<std::string>*>(ptr);
                    pArr->clear();
                }
            }break;
            default: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ObjectArray*>(ptr);
                    pArr->clear();
                }
            }break;
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteHashtableContains(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            for (auto&& _arg : m_Args) {
                if (!_arg.isNull())
                    _arg(gvars, lvars);
            }
            auto& hash = m_ObjInfo;
            auto& ix = m_ArgInfos[0];
            const std::shared_ptr<void>& p = Brace::VarGetObject((hash.IsGlobal ? gvars : lvars), hash.VarIndex);
            int objTypeId = hash.ObjectTypeId;
            switch (objTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, std::string>*>(ptr);
                    bool v = HashtableContains((*pHashtable), vix);
                    Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, int64_t>*>(ptr);
                    bool v = HashtableContains((*pHashtable), vix);
                    Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, double>*>(ptr);
                    bool v = HashtableContains((*pHashtable), vix);
                    Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, bool>*>(ptr);
                    bool v = HashtableContains((*pHashtable), vix);
                    Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, std::string>*>(ptr);
                    bool v = HashtableContains((*pHashtable), vix);
                    Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, int64_t>*>(ptr);
                    bool v = HashtableContains((*pHashtable), vix);
                    Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, double>*>(ptr);
                    bool v = HashtableContains((*pHashtable), vix);
                    Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, bool>*>(ptr);
                    bool v = HashtableContains((*pHashtable), vix);
                    Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                }
            }break;
            default: {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
                if (nullptr != pInfo) {
                    if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
                        auto* ptr = p.get();
                        if (nullptr != ptr) {
                            int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                            auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
                            bool v = HashtableContains((*pHashtable), vix);
                            Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                        }
                    }
                    else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
                        auto* ptr = p.get();
                        if (nullptr != ptr) {
                            std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                            auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
                            bool v = HashtableContains((*pHashtable), vix);
                            Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
                        }
                    }
                }
            }break;
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteHashtableAdd(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            for (auto&& _arg : m_Args) {
                if (!_arg.isNull())
                    _arg(gvars, lvars);
            }
            auto& hash = m_ObjInfo;
            auto& ix = m_ArgInfos[0];
            auto& val = m_ArgInfos[1];
            const std::shared_ptr<void>& p = Brace::VarGetObject((hash.IsGlobal ? gvars : lvars), hash.VarIndex);
            int objTypeId = hash.ObjectTypeId;
            switch (objTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
                const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, std::string>*>(ptr);
                    (*pHashtable)[vix] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
                int64_t v = Brace::VarGetInt64((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, int64_t>*>(ptr);
                    (*pHashtable)[vix] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
                double v = Brace::VarGetDouble((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, double>*>(ptr);
                    (*pHashtable)[vix] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
                bool v = Brace::VarGetBool((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, bool>*>(ptr);
                    (*pHashtable)[vix] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
                const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, std::string>*>(ptr);
                    (*pHashtable)[static_cast<size_t>(vix)] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
                int64_t v = Brace::VarGetInt64((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, int64_t>*>(ptr);
                    (*pHashtable)[static_cast<size_t>(vix)] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
                double v = Brace::VarGetDouble((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, double>*>(ptr);
                    (*pHashtable)[static_cast<size_t>(vix)] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
                bool v = Brace::VarGetBool((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, bool>*>(ptr);
                    (*pHashtable)[static_cast<size_t>(vix)] = v;
                }
            }break;
            default: {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
                if (nullptr != pInfo) {
                    if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
                        auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
                        auto* ptr = p.get();
                        if (nullptr != ptr) {
                            int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                            auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
                            (*pHashtable)[static_cast<size_t>(vix)] = v;
                        }
                    }
                    else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
                        auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
                        auto* ptr = p.get();
                        if (nullptr != ptr) {
                            std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                            auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
                            (*pHashtable)[vix] = v;
                        }
                    }
                }
            }break;
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteHashtableRemove(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            for (auto&& _arg : m_Args) {
                if (!_arg.isNull())
                    _arg(gvars, lvars);
            }
            auto& hash = m_ObjInfo;
            auto& ix = m_ArgInfos[0];
            const std::shared_ptr<void>& p = Brace::VarGetObject((hash.IsGlobal ? gvars : lvars), hash.VarIndex);
            int objTypeId = hash.ObjectTypeId;
            switch (objTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, std::string>*>(ptr);
                    pHashtable->erase(vix);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, int64_t>*>(ptr);
                    pHashtable->erase(vix);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, double>*>(ptr);
                    pHashtable->erase(vix);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, bool>*>(ptr);
                    pHashtable->erase(vix);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, std::string>*>(ptr);
                    pHashtable->erase(vix);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, int64_t>*>(ptr);
                    pHashtable->erase(vix);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, double>*>(ptr);
                    pHashtable->erase(vix);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, bool>*>(ptr);
                    pHashtable->erase(vix);
                }
            }break;
            default: {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
                if (nullptr != pInfo) {
                    if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
                        auto* ptr = p.get();
                        if (nullptr != ptr) {
                            int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                            auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
                            pHashtable->erase(vix);
                        }
                    }
                    else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
                        auto* ptr = p.get();
                        if (nullptr != ptr) {
                            std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                            auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
                            pHashtable->erase(vix);
                        }
                    }
                }
            }break;
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteHashtableClear(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            auto& hash = m_ObjInfo;
            const std::shared_ptr<void>& p = Brace::VarGetObject((hash.IsGlobal ? gvars : lvars), hash.VarIndex);
            int objTypeId = hash.ObjectTypeId;
            switch (objTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<std::string, std::string>*>(ptr);
                    pHashtable->clear();
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<std::string, int64_t>*>(ptr);
                    pHashtable->clear();
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<std::string, double>*>(ptr);
                    pHashtable->clear();
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<std::string, bool>*>(ptr);
                    pHashtable->clear();
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<int64_t, std::string>*>(ptr);
                    pHashtable->clear();
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<int64_t, int64_t>*>(ptr);
                    pHashtable->clear();
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<int64_t, double>*>(ptr);
                    pHashtable->clear();
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<int64_t, bool>*>(ptr);
                    pHashtable->clear();
                }
            }break;
            default: {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
                if (nullptr != pInfo) {
                    if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
                        auto* ptr = p.get();
                        if (nullptr != ptr) {
                            auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
                            pHashtable->clear();
                        }
                    }
                    else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
                        auto* ptr = p.get();
                        if (nullptr != ptr) {
                            auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
                            pHashtable->clear();
                        }
                    }
                }
            }break;
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    private:
        ArrayHashtableMemberCallProvider(Brace::BraceScript& interpreter) :AbstractMemberCallApiProvider(interpreter), m_Obj(), m_ObjInfo(), m_Member(), m_Args(), m_ArgInfos(), m_ResultInfo()
        {
        }
    private:
        Brace::BraceApiExecutor m_Obj;
        Brace::OperandRuntimeInfo m_ObjInfo;
        std::string m_Member;
        std::vector<Brace::BraceApiExecutor> m_Args;
        std::vector<Brace::OperandRuntimeInfo> m_ArgInfos;
        Brace::OperandRuntimeInfo m_ResultInfo;
    private:
        template<typename VectorT, typename ValT>
        static inline void VectorInsert(VectorT& vr, int64_t pos, const ValT& val)
        {
            auto it = vr.begin();
            std::advance(it, pos);
            if (it != vr.end())
                vr.insert(it, val);
            else
                vr.push_back(val);
        }
        template<typename VectorT, typename ValT>
        static inline void VectorInsert(VectorT& vr, int64_t pos, ValT&& val)
        {
            auto it = vr.begin();
            std::advance(it, pos);
            if (it != vr.end())
                vr.insert(it, std::move(val));
            else
                vr.push_back(std::move(val));
        }
        template<typename VectorT>
        static inline void VectorErase(VectorT& vr, int64_t pos)
        {
            auto it = vr.begin();
            std::advance(it, pos);
            if (it != vr.end())
                vr.erase(it);
        }
        template<typename HashtableT, typename ValT>
        static inline bool HashtableContains(const HashtableT& hash, const ValT& val)
        {
            auto it = hash.find(val);
            return it != hash.end();
        }
    };
    class ArrayHashtableMemberSetProvider final : public AbstractMemberSetApiProvider
    {
        friend class MemberSetExp;
    protected:
        virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
        {
            return false;
        }
    private:
        ArrayHashtableMemberSetProvider(Brace::BraceScript& interpreter) :AbstractMemberSetApiProvider(interpreter)
        {
        }
    };
    class ArrayHashtableMemberGetProvider final : public AbstractMemberGetApiProvider
    {
        friend class MemberGetExp;
    protected:
        virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            if (data.GetParamNum() != 2)
                return false;
            std::swap(m_Obj, obj);
            m_ObjInfo = objInfo;
            std::swap(m_Member, member);
            bool isArray = false;
            bool isHashtable = false;
            switch (objInfo.ObjectTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY:
            case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY:
            case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY:
            case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY:
                isArray = true;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE:
            case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE:
            case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE:
            case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE:
            case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE:
            case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE:
            case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE:
            case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE:
                isHashtable = true;
                break;
            }
            switch (braceObjInfo.ObjectCategory) {
            case BRACE_OBJECT_CATEGORY_OBJ_ARRAY:
                isArray = true;
                break;
            case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE:
                isHashtable = true;
                break;
            case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE:
                isHashtable = true;
                break;
            }
            if (isArray) {
                if (m_Member == "length") {
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_INT32;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &ArrayHashtableMemberGetProvider::ExecuteArrayLength);
                    return true;
                }
            }
            else if (isHashtable) {
                if (m_Member == "count") {
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_INT32;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &ArrayHashtableMemberGetProvider::ExecuteHashtableCount);
                    return true;
                }
            }
            std::stringstream ss;
            ss << "Unknown member " << m_Member << " line: " << data.GetLine();
            LogError(ss.str());
            return false;
        }
    private:
        int ExecuteArrayLength(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            const std::shared_ptr<void>& p = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            int objTypeId = m_ObjInfo.ObjectTypeId;
            switch (objTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<bool>*>(ptr);
                    size_t v = pArr->size();
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<int>*>(ptr);
                    size_t v = pArr->size();
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<double>*>(ptr);
                    size_t v = pArr->size();
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<std::string>*>(ptr);
                    size_t v = pArr->size();
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                }
            }break;
            default: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ObjectArray*>(ptr);
                    size_t v = pArr->size();
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                }
            }break;
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteHashtableCount(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            const std::shared_ptr<void>& p = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
            int objTypeId = m_ObjInfo.ObjectTypeId;
            switch (objTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<int64_t, bool>*>(ptr);
                    size_t v = pHashtable->size();
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<int64_t, int64_t>*>(ptr);
                    size_t v = pHashtable->size();
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<int64_t, double>*>(ptr);
                    size_t v = pHashtable->size();
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<int64_t, std::string>*>(ptr);
                    size_t v = pHashtable->size();
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<std::string, bool>*>(ptr);
                    size_t v = pHashtable->size();
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<std::string, int64_t>*>(ptr);
                    size_t v = pHashtable->size();
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<std::string, double>*>(ptr);
                    size_t v = pHashtable->size();
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<std::string, std::string>*>(ptr);
                    size_t v = pHashtable->size();
                    Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                }
            }break;
            default: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
                    if (nullptr != pInfo) {
                        if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
                            auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
                            size_t v = pHashtable->size();
                            Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                        }
                        else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
                            auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
                            size_t v = pHashtable->size();
                            Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
                        }
                    }
                }
            }break;
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    private:
        ArrayHashtableMemberGetProvider(Brace::BraceScript& interpreter) :AbstractMemberGetApiProvider(interpreter), m_Obj(), m_ObjInfo(), m_Member(), m_ResultInfo()
        {
        }
    private:
        Brace::BraceApiExecutor m_Obj;
        Brace::OperandRuntimeInfo m_ObjInfo;
        std::string m_Member;
        Brace::OperandRuntimeInfo m_ResultInfo;
    };
    class ArrayHashtableCollectionCallProvider final : public AbstractCollectionCallApiProvider
    {
        friend class CollectionCallExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) const override
        {
            return false;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo) const override
        {
        }
    private:
        ArrayHashtableCollectionCallProvider(Brace::BraceScript& interpreter) :AbstractCollectionCallApiProvider(interpreter)
        {}
    };
    class ArrayHashtableCollectionSetProvider final : public AbstractCollectionSetApiProvider
    {
        friend class CollectionSetExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, const Brace::OperandLoadtimeInfo& val, Brace::OperandLoadtimeInfo& resultInfo) const override
        {
            bool isArray = false;
            bool isHashtable = false;
            bool isIntKey = true;
            int dataType = Brace::BRACE_DATA_TYPE_OBJECT;
            int objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
            switch (braceObjInfo.ObjectTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY:
                isArray = true;
                dataType = Brace::BRACE_DATA_TYPE_STRING;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY:
                isArray = true;
                dataType = Brace::BRACE_DATA_TYPE_INT64;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY:
                isArray = true;
                dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY:
                isArray = true;
                dataType = Brace::BRACE_DATA_TYPE_BOOL;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                dataType = Brace::BRACE_DATA_TYPE_STRING;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                dataType = Brace::BRACE_DATA_TYPE_INT64;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                dataType = Brace::BRACE_DATA_TYPE_BOOL;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE:
                isHashtable = true;
                dataType = Brace::BRACE_DATA_TYPE_STRING;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE:
                isHashtable = true;
                dataType = Brace::BRACE_DATA_TYPE_INT64;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE:
                isHashtable = true;
                dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE:
                isHashtable = true;
                dataType = Brace::BRACE_DATA_TYPE_BOOL;
                break;
            }
            switch (braceObjInfo.ObjectCategory) {
            case BRACE_OBJECT_CATEGORY_OBJ_ARRAY:
                isArray = true;
                objTypeId = braceObjInfo.GetTypeParamObjTypeId(0);
                break;
            case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE:
                isHashtable = true;
                objTypeId = braceObjInfo.GetTypeParamObjTypeId(1);
                break;
            case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                objTypeId = braceObjInfo.GetTypeParamObjTypeId(1);
                break;
            }
            if (isArray) {
                if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
                    std::stringstream ss;
                    ss << "Array's index must be integer ! line: " << data.GetLine();
                    LogError(ss.str());
                    return false;
                }
                if (!CanAssign(dataType, objTypeId, val.Type, val.ObjectTypeId)) {
                    std::stringstream ss;
                    ss << "Array element's type and val type dismatch ! line: " << data.GetLine();
                    LogError(ss.str());
                    return false;
                }
                resultInfo = val;
                return true;
            }
            else if (isHashtable) {
                if (isIntKey) {
                    if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
                        std::stringstream ss;
                        ss << "key must be integer ! line: " << data.GetLine();
                        LogError(ss.str());
                        return false;
                    }
                }
                else {
                    if (ix.Type != Brace::BRACE_DATA_TYPE_STRING) {
                        std::stringstream ss;
                        ss << "key must be string ! line: " << data.GetLine();
                        LogError(ss.str());
                        return false;
                    }
                }
                if (!CanAssign(dataType, objTypeId, val.Type, val.ObjectTypeId)) {
                    std::stringstream ss;
                    ss << "Hashtable type and val type dismatch ! line: " << data.GetLine();
                    LogError(ss.str());
                    return false;
                }
                resultInfo = val;
                return true;
            }
            return false;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& val, const Brace::OperandRuntimeInfo& resultInfo) const override
        {
            const std::shared_ptr<void>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
            int objTypeId = arr.ObjectTypeId;
            switch (objTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
                bool v = Brace::VarGetBoolean((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pArr = static_cast<ArrayT<bool>*>(ptr);
                    (*pArr)[static_cast<size_t>(vix)] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
                int64_t v = Brace::VarGetI64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pArr = static_cast<ArrayT<int64_t>*>(ptr);
                    (*pArr)[static_cast<size_t>(vix)] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
                double v = Brace::VarGetF64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pArr = static_cast<ArrayT<double>*>(ptr);
                    (*pArr)[static_cast<size_t>(vix)] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
                const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pArr = static_cast<ArrayT<std::string>*>(ptr);
                    (*pArr)[static_cast<size_t>(vix)] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
                const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, std::string>*>(ptr);
                    (*pHashtable)[vix] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
                int64_t v = Brace::VarGetInt64((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, int64_t>*>(ptr);
                    (*pHashtable)[vix] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
                double v = Brace::VarGetDouble((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, double>*>(ptr);
                    (*pHashtable)[vix] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
                bool v = Brace::VarGetBool((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, bool>*>(ptr);
                    (*pHashtable)[vix] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
                const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, std::string>*>(ptr);
                    (*pHashtable)[static_cast<size_t>(vix)] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
                int64_t v = Brace::VarGetInt64((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, int64_t>*>(ptr);
                    (*pHashtable)[static_cast<size_t>(vix)] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
                double v = Brace::VarGetDouble((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, double>*>(ptr);
                    (*pHashtable)[static_cast<size_t>(vix)] = v;
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
                bool v = Brace::VarGetBool((val.IsGlobal ? gvars : lvars), val.VarIndex);
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, bool>*>(ptr);
                    (*pHashtable)[static_cast<size_t>(vix)] = v;
                }
            }break;
            default: {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
                if (nullptr != pInfo) {
                    if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_OBJ_ARRAY) {
                        auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
                        auto* ptr = p.get();
                        if (nullptr != ptr) {
                            int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                            auto* pArr = static_cast<ObjectArray*>(ptr);
                            (*pArr)[static_cast<size_t>(vix)] = v;
                        }
                    }
                    else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
                        auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
                        auto* ptr = p.get();
                        if (nullptr != ptr) {
                            int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                            auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
                            (*pHashtable)[static_cast<size_t>(vix)] = v;
                        }
                    }
                    else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
                        auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
                        auto* ptr = p.get();
                        if (nullptr != ptr) {
                            std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                            auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
                            (*pHashtable)[vix] = v;
                        }
                    }
                }
            }break;
            }
        }
    private:
        ArrayHashtableCollectionSetProvider(Brace::BraceScript& interpreter) :AbstractCollectionSetApiProvider(interpreter)
        {}
    };
    class ArrayHashtableCollectionGetProvider final : public AbstractCollectionGetApiProvider
    {
        friend class CollectionGetExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, Brace::OperandLoadtimeInfo& resultInfo) const override
        {
            bool isArray = false;
            bool isHashtable = false;
            bool isIntKey = true;
            int dataType = Brace::BRACE_DATA_TYPE_OBJECT;
            int objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
            switch (braceObjInfo.ObjectTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY:
                isArray = true;
                dataType = Brace::BRACE_DATA_TYPE_STRING;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY:
                isArray = true;
                dataType = Brace::BRACE_DATA_TYPE_INT64;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY:
                isArray = true;
                dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY:
                isArray = true;
                dataType = Brace::BRACE_DATA_TYPE_BOOL;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                dataType = Brace::BRACE_DATA_TYPE_STRING;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                dataType = Brace::BRACE_DATA_TYPE_INT64;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                dataType = Brace::BRACE_DATA_TYPE_BOOL;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE:
                isHashtable = true;
                dataType = Brace::BRACE_DATA_TYPE_STRING;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE:
                isHashtable = true;
                dataType = Brace::BRACE_DATA_TYPE_INT64;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE:
                isHashtable = true;
                dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
                break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE:
                isHashtable = true;
                dataType = Brace::BRACE_DATA_TYPE_BOOL;
                break;
            }
            switch (braceObjInfo.ObjectCategory) {
            case BRACE_OBJECT_CATEGORY_OBJ_ARRAY:
                isArray = true;
                objTypeId = braceObjInfo.GetTypeParamObjTypeId(0);
                break;
            case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE:
                isHashtable = true;
                objTypeId = braceObjInfo.GetTypeParamObjTypeId(1);
                break;
            case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE:
                isHashtable = true;
                isIntKey = false;
                objTypeId = braceObjInfo.GetTypeParamObjTypeId(1);
                break;
            }
            if (isArray) {
                if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
                    std::stringstream ss;
                    ss << "Array's index must be integer ! line: " << data.GetLine();
                    LogError(ss.str());
                    return false;
                }
                resultInfo.Type = dataType;
                resultInfo.ObjectTypeId = objTypeId;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                return true;
            }
            else if (isHashtable) {
                if (isIntKey) {
                    if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
                        std::stringstream ss;
                        ss << "key must be integer ! line: " << data.GetLine();
                        LogError(ss.str());
                        return false;
                    }
                }
                else {
                    if (ix.Type != Brace::BRACE_DATA_TYPE_STRING) {
                        std::stringstream ss;
                        ss << "key must be string ! line: " << data.GetLine();
                        LogError(ss.str());
                        return false;
                    }
                }
                resultInfo.Type = dataType;
                resultInfo.ObjectTypeId = objTypeId;
                resultInfo.Name = GenTempVarName();
                resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                return true;
            }
            return false;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& resultInfo) const override
        {
            const std::shared_ptr<void>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
            int objTypeId = arr.ObjectTypeId;
            switch (objTypeId) {
            case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pArr = static_cast<ArrayT<bool>*>(ptr);
                    bool v = (*pArr)[static_cast<size_t>(vix)];
                    Brace::VarSetBool((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pArr = static_cast<ArrayT<int64_t>*>(ptr);
                    int64_t v = (*pArr)[static_cast<size_t>(vix)];
                    Brace::VarSetInt64((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pArr = static_cast<ArrayT<double>*>(ptr);
                    double v = (*pArr)[static_cast<size_t>(vix)];
                    Brace::VarSetDouble((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pArr = static_cast<ArrayT<std::string>*>(ptr);
                    const std::string& v = (*pArr)[static_cast<size_t>(vix)];
                    Brace::VarSetString((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, bool>*>(ptr);
                    bool v = (*pHashtable)[static_cast<size_t>(vix)];
                    Brace::VarSetBool((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, int64_t>*>(ptr);
                    int64_t v = (*pHashtable)[static_cast<size_t>(vix)];
                    Brace::VarSetInt64((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, double>*>(ptr);
                    double v = (*pHashtable)[static_cast<size_t>(vix)];
                    Brace::VarSetDouble((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<int64_t, std::string>*>(ptr);
                    const std::string& v = (*pHashtable)[static_cast<size_t>(vix)];
                    Brace::VarSetString((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, bool>*>(ptr);
                    bool v = (*pHashtable)[vix];
                    Brace::VarSetBool((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, int64_t>*>(ptr);
                    int64_t v = (*pHashtable)[vix];
                    Brace::VarSetInt64((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, double>*>(ptr);
                    double v = (*pHashtable)[vix];
                    Brace::VarSetDouble((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                }
            }break;
            case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                    auto* pHashtable = static_cast<HashtableT<std::string, std::string>*>(ptr);
                    const std::string& v = (*pHashtable)[vix];
                    Brace::VarSetString((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                }
            }break;
            default: {
                auto* ptr = p.get();
                if (nullptr != ptr) {
                    auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
                    if (nullptr != pInfo) {
                        switch (pInfo->ObjectCategory) {
                        case BRACE_OBJECT_CATEGORY_OBJ_ARRAY: {
                            int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                            auto* pArr = static_cast<ObjectArray*>(ptr);
                            auto& v = (*pArr)[static_cast<size_t>(vix)];
                            Brace::VarSetObject((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                        }break;
                        case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE: {
                            int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                            auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
                            auto& v = (*pHashtable)[static_cast<size_t>(vix)];
                            Brace::VarSetObject((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                        }break;
                        case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE: {
                            std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
                            auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
                            auto& v = (*pHashtable)[vix];
                            Brace::VarSetObject((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
                        }break;
                        }
                    }
                }
            }break;
            }
        }
    private:
        ArrayHashtableCollectionGetProvider(Brace::BraceScript& interpreter) :AbstractCollectionGetApiProvider(interpreter)
        {}
    };
    class ArrayHashtableLoopListProvider final : public AbstractLoopListApiProvider
    {
        friend class LoopListExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::ISyntaxComponent& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor) override
        {
            return TypeInference(listInfo, executor);
        }
        virtual void StoreRuntimeInfo(Brace::OperandRuntimeInfo&& listInfo, Brace::BraceApiExecutor&& list, std::vector<Brace::BraceApiExecutor>&& statements, const std::vector<int>& objVars) override
        {
            std::swap(m_ListInfo, listInfo);
            std::swap(m_List, list);
            std::swap(m_Statements, statements);
            m_ObjVars = objVars;
        }
    private:
        ArrayHashtableLoopListProvider(Brace::BraceScript& interpreter) :AbstractLoopListApiProvider(interpreter), m_IteratorIndex(INVALID_INDEX), m_IteratorIndexV(INVALID_INDEX), m_List(), m_ListInfo(), m_Statements(), m_ObjVars()
        {}
    private:
        bool TypeInference(const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor)
        {
            if (listInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
                if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY) {
                    m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_BOOL, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteBoolArray);
                    return true;
                }
                else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY) {
                    m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntArray);
                    return true;
                }
                else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY) {
                    m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_DOUBLE, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteFloatArray);
                    return true;
                }
                else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY) {
                    m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStringArray);
                    return true;
                }
                else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE) {
                    m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_BOOL, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntBoolHashtable);
                    return true;
                }
                else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE) {
                    m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntIntHashtable);
                    return true;
                }
                else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE) {
                    m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_DOUBLE, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntFloatHashtable);
                    return true;
                }
                else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE) {
                    m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntStrHashtable);
                    return true;
                }
                else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE) {
                    m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_BOOL, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrBoolHashtable);
                    return true;
                }
                else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE) {
                    m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrIntHashtable);
                    return true;
                }
                else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE) {
                    m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_DOUBLE, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrFloatHashtable);
                    return true;
                }
                else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE) {
                    m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                    executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrStrHashtable);
                    return true;
                }
                else {
                    auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(listInfo.ObjectTypeId);
                    if (nullptr != pInfo) {
                        if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_OBJ_ARRAY) {
                            m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_OBJECT, pInfo->GetTypeParamObjTypeId(0));
                            executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteObjectArray);
                            return true;
                        }
                        else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
                            m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                            m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_OBJECT, pInfo->GetTypeParamObjTypeId(1));
                            executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntObjHashtable);
                            return true;
                        }
                        else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
                            m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                            m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_OBJECT, pInfo->GetTypeParamObjTypeId(1));
                            executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrObjHashtable);
                            return true;
                        }
                    }
                }
            }
            return false;
        }
    private:
        int ExecuteBoolArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<bool>*>(ptr);
                    for (auto val : (*pArr)) {
                        Brace::VarSetBool(lvars, m_IteratorIndex, val);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteIntArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<int64_t>*>(ptr);
                    for (auto val : (*pArr)) {
                        Brace::VarSetInt64(lvars, m_IteratorIndex, val);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteFloatArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<double>*>(ptr);
                    for (auto val : (*pArr)) {
                        Brace::VarSetDouble(lvars, m_IteratorIndex, val);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteStringArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ArrayT<std::string>*>(ptr);
                    for (auto&& val : (*pArr)) {
                        Brace::VarSetString(lvars, m_IteratorIndex, val);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteObjectArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pArr = static_cast<ObjectArray*>(ptr);
                    for (auto&& val : (*pArr)) {
                        Brace::VarSetObject(lvars, m_IteratorIndex, val);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteIntBoolHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<int64_t, bool>*>(ptr);
                    for (auto&& val : (*pHashtable)) {
                        Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
                        Brace::VarSetBool(lvars, m_IteratorIndexV, val.second);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteIntIntHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<int64_t, int64_t>*>(ptr);
                    for (auto&& val : (*pHashtable)) {
                        Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
                        Brace::VarSetInt64(lvars, m_IteratorIndexV, val.second);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteIntFloatHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<int64_t, double>*>(ptr);
                    for (auto&& val : (*pHashtable)) {
                        Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
                        Brace::VarSetDouble(lvars, m_IteratorIndexV, val.second);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteIntStrHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<int64_t, std::string>*>(ptr);
                    for (auto&& val : (*pHashtable)) {
                        Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
                        Brace::VarSetString(lvars, m_IteratorIndexV, val.second);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteIntObjHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
                    for (auto&& val : (*pHashtable)) {
                        Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
                        Brace::VarSetObject(lvars, m_IteratorIndexV, val.second);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteStrBoolHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<std::string, bool>*>(ptr);
                    for (auto&& val : (*pHashtable)) {
                        Brace::VarSetString(lvars, m_IteratorIndex, val.first);
                        Brace::VarSetBool(lvars, m_IteratorIndexV, val.second);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteStrIntHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<std::string, int64_t>*>(ptr);
                    for (auto&& val : (*pHashtable)) {
                        Brace::VarSetString(lvars, m_IteratorIndex, val.first);
                        Brace::VarSetInt64(lvars, m_IteratorIndexV, val.second);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteStrFloatHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<std::string, double>*>(ptr);
                    for (auto&& val : (*pHashtable)) {
                        Brace::VarSetString(lvars, m_IteratorIndex, val.first);
                        Brace::VarSetDouble(lvars, m_IteratorIndexV, val.second);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteStrStrHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<HashtableT<std::string, std::string>*>(ptr);
                    for (auto&& val : (*pHashtable)) {
                        Brace::VarSetString(lvars, m_IteratorIndex, val.first);
                        Brace::VarSetString(lvars, m_IteratorIndexV, val.second);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteStrObjHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
                    for (auto&& val : (*pHashtable)) {
                        Brace::VarSetString(lvars, m_IteratorIndex, val.first);
                        Brace::VarSetObject(lvars, m_IteratorIndexV, val.second);
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    private:
        int m_IteratorIndex;
        int m_IteratorIndexV;
        Brace::BraceApiExecutor m_List;
        Brace::OperandRuntimeInfo m_ListInfo;
        std::vector<Brace::BraceApiExecutor> m_Statements;
        std::vector<int> m_ObjVars;
    };
    class ArrayHashtableLinqProvider final : public AbstractLinqApiProvider
    {
        friend class LinqExp;
        enum OperationType
        {
            OPERATION_UNKNOWN = -1,
            OPERATION_ORDERBY = 0,
            OPERATION_ORDERBYDESC,
            OPERATION_TOP,
            OPERATION_WHERE,
            OPERATION_NUM
        };
        struct CmpVal
        {
            double NumVal;
            std::string StrVal;
        };
    protected:
        virtual bool LoadLinqCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, Brace::OperandLoadtimeInfo&& listInfo, Brace::BraceApiExecutor&& list, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<int>&& objVars, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            if (member == "orderby") {
                m_Operation = OPERATION_ORDERBY;
            }
            else if (member == "orderbydesc") {
                m_Operation = OPERATION_ORDERBYDESC;
            }
            else if (member == "top") {
                m_Operation = OPERATION_TOP;
            }
            else if (member == "where") {
                m_Operation = OPERATION_WHERE;
            }

            m_IteratorIndex = iteratorIndex;
            m_ListInfo = listInfo;
            std::swap(m_List, list);
            for (auto&& argInfo : argInfos) {
                m_ArgInfos.push_back(argInfo);
            }
            std::swap(m_Args, args);
            resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
            resultInfo.ObjectTypeId = listInfo.ObjectTypeId;
            resultInfo.Name = GenTempVarName();
            resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
            m_ResultInfo = resultInfo;
            std::swap(m_ObjVars, objVars);
            executor.attach(this, &ArrayHashtableLinqProvider::ExecuteObjectArray);
            return true;
        }
    private:
        ArrayHashtableLinqProvider(Brace::BraceScript& interpreter) :AbstractLinqApiProvider(interpreter), m_Operation(OPERATION_UNKNOWN), m_IteratorIndex(INVALID_INDEX), m_List(), m_ListInfo(), m_ArgInfos(), m_Args(), m_ResultInfo(), m_ObjVars()
        {}
    private:
        int ExecuteObjectArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            if (nullptr != obj) {
                auto* ptr = obj.get();
                if (nullptr != ptr) {
                    auto* pNewArr = new ObjectArray();
                    std::shared_ptr<void> newArr(pNewArr);
                    Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, newArr);
                    auto* pArr = static_cast<ObjectArray*>(ptr);
                    switch (m_Operation) {
                    case OPERATION_ORDERBY:
                    case OPERATION_ORDERBYDESC:
                        ExecuteOrderBy(gvars, lvars, pArr, pNewArr, m_Operation == OPERATION_ORDERBY);
                        break;
                    case OPERATION_TOP:
                        ExecuteTop(gvars, lvars, pArr, pNewArr);
                        break;
                    case OPERATION_WHERE:
                        ExecuteWhere(gvars, lvars, pArr, pNewArr);
                        break;
                    default:
                        break;
                    }
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        void ExecuteOrderBy(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const ObjectArray* pArr, ObjectArray* pNewArr, bool asc)const
        {
            for (auto&& val : (*pArr)) {
                pNewArr->push_back(val);
            }
            std::vector<CmpVal> sortVals{};
            std::sort(pNewArr->begin(), pNewArr->end(), [&](auto& e1, auto& e2) {
                Brace::VarSetObject(lvars, m_IteratorIndex, e1);
                for (auto&& arg : m_Args) {
                    if (!arg.isNull())
                        arg(gvars, lvars);
                }
                sortVals.clear();
                for (auto&& argInfo : m_ArgInfos) {
                    CmpVal cv;
                    if (Brace::IsStringType(argInfo.Type))
                        cv.StrVal = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                    else
                        cv.NumVal = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
                    sortVals.push_back(cv);
                }
                Brace::VarSetObject(lvars, m_IteratorIndex, e2);
                for (auto&& arg : m_Args) {
                    if (!arg.isNull())
                        arg(gvars, lvars);
                }
                int ix = 0;
                for (auto&& argInfo : m_ArgInfos) {
                    const CmpVal& cv = sortVals[ix++];
                    if (Brace::IsStringType(argInfo.Type)) {
                        const std::string& v2 = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        if (asc) {
                            if (cv.StrVal < v2)
                                return true;
                            else if (cv.StrVal > v2)
                                return false;
                        }
                        else {
                            if (cv.StrVal > v2)
                                return true;
                            else if (cv.StrVal < v2)
                                return false;
                        }
                    }
                    else {
                        double v2 = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
                        if (asc) {
                            if (cv.NumVal < v2)
                                return true;
                            else if (cv.NumVal > v2)
                                return false;
                        }
                        else {
                            if (cv.NumVal > v2)
                                return true;
                            else if (cv.NumVal < v2)
                                return false;
                        }
                    }
                }
                return false;
            });
            FreeObjVars(lvars, m_ObjVars);
        }
        void ExecuteTop(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const ObjectArray* pArr, ObjectArray* pNewArr)const
        {
            for (auto&& arg : m_Args) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            auto& argInfo = m_ArgInfos[0];
            int64_t n = Brace::VarGetI64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
            int64_t ct = 0;
            for (auto&& val : (*pArr)) {
                pNewArr->push_back(val);
                ++ct;
                if (ct >= n)
                    break;
            }
            FreeObjVars(lvars, m_ObjVars);
        }
        void ExecuteWhere(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const ObjectArray* pArr, ObjectArray* pNewArr)const
        {
            for (auto&& val : (*pArr)) {
                Brace::VarSetObject(lvars, m_IteratorIndex, val);
                for (auto&& arg : m_Args) {
                    if (!arg.isNull())
                        arg(gvars, lvars);
                }
                auto& argInfo = m_ArgInfos[0];
                bool v = Brace::VarGetBoolean((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
                if (v)
                    pNewArr->push_back(val);
            }
            FreeObjVars(lvars, m_ObjVars);
        }
    private:
        OperationType m_Operation;
        int m_IteratorIndex;
        Brace::BraceApiExecutor m_List;
        Brace::OperandRuntimeInfo m_ListInfo;
        std::vector<Brace::OperandRuntimeInfo> m_ArgInfos;
        std::vector<Brace::BraceApiExecutor> m_Args;
        Brace::OperandRuntimeInfo m_ResultInfo;
        std::vector<int> m_ObjVars;
    };
    class ArrayHashtableSelectProvider final : public AbstractSelectApiProvider
    {
        friend class SelectExp;
        struct CmpVal
        {
            bool IsStr;
            double NumVal;
            std::string StrVal;
            double NewNumVal;
            std::string NewStrVal;
        };
    protected:
        virtual bool LoadSelect(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<int>&& statMethods, std::vector<int>&& objVars) override
        {
            m_SelectIteratorIndex = iteratorIndex;
            for (auto&& argInfo : argInfos) {
                m_SelectArgInfos.push_back(argInfo);
            }
            std::swap(m_SelectArgs, args);
            std::swap(m_SelectStats, statMethods);
            std::swap(m_SelectObjVars, objVars);
            return true;
        }
        virtual bool LoadTop(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, std::vector<int>&& objVars) override
        {
            m_TopArgInfo = argInfo;
            std::swap(m_TopArg, arg);
            std::swap(m_TopObjVars, objVars);
            return true;
        }
        virtual bool LoadFromList(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg) override
        {
            m_ListInfo = argInfo;
            std::swap(m_List, arg);
            return true;
        }
        virtual bool LoadFromType(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const std::string& type) override
        {
            m_Type = type;
            return true;
        }
        virtual bool LoadWhere(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, std::vector<int>&& objVars) override
        {
            m_WhereIteratorIndex = iteratorIndex;
            m_WhereArgInfo = argInfo;
            std::swap(m_WhereArg, arg);
            std::swap(m_WhereObjVars, objVars);
            return true;
        }
        virtual bool LoadOrderBy(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<bool>&& ascOrDescs, std::vector<int>&& objVars) override
        {
            m_OrderIteratorIndex = iteratorIndex;
            for (auto&& argInfo : argInfos) {
                m_OrderArgInfos.push_back(argInfo);
            }
            std::swap(m_OrderArgs, args);
            std::swap(m_OrderAscs, ascOrDescs);
            std::swap(m_OrderObjVars, objVars);
            return true;
        }
        virtual bool LoadGroupBy(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<int>&& objVars) override
        {
            m_GroupIteratorIndex = iteratorIndex;
            for (auto&& argInfo : argInfos) {
                m_GroupArgInfos.push_back(argInfo);
            }
            std::swap(m_GroupArgs, args);
            std::swap(m_GroupObjVars, objVars);
            return true;
        }
        virtual bool LoadHaving(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg) override
        {
            m_HavingArgInfo = argInfo;
            std::swap(m_HavingArg, arg);
            return true;
        }
        virtual bool LoadStatements(const Brace::FuncInfo& func, const DslData::FunctionData& data, std::vector<Brace::BraceApiExecutor>&& statements, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            std::swap(m_Statements, statements);
            executor.attach(this, &ArrayHashtableSelectProvider::ExecuteObjectArray);
            return true;
        }
        virtual void LoadResultIterator(std::vector<Brace::OperandLoadtimeInfo>&& iterators, std::vector<int>&& objVars) override
        {
            for (auto&& itInfo : iterators) {
                m_Iterators.push_back(itInfo);
                m_IteratorAssigns.push_back(Brace::GetVarAssignPtr(itInfo.Type, false, itInfo.Type, false));
            }
            std::swap(m_ObjVars, objVars);
        }
    private:
        ArrayHashtableSelectProvider(Brace::BraceScript& interpreter) :AbstractSelectApiProvider(interpreter)
            , m_Type()
            , m_List()
            , m_ListInfo()
            , m_SelectIteratorIndex(INVALID_INDEX)
            , m_SelectArgInfos()
            , m_SelectArgs()
            , m_SelectStats()
            , m_SelectObjVars()
            , m_TopArgInfo()
            , m_TopArg()
            , m_TopObjVars()
            , m_WhereIteratorIndex(INVALID_INDEX)
            , m_WhereArgInfo()
            , m_WhereArg()
            , m_WhereObjVars()
            , m_OrderIteratorIndex(INVALID_INDEX)
            , m_OrderArgInfos()
            , m_OrderArgs()
            , m_OrderAscs()
            , m_OrderObjVars()
            , m_GroupIteratorIndex(INVALID_INDEX)
            , m_GroupArgInfos()
            , m_GroupArgs()
            , m_GroupObjVars()
            , m_Iterators()
            , m_IteratorAssigns()
            , m_HavingArgInfo()
            , m_HavingArg()
            , m_Statements()
            , m_ObjVars()
        {}
    private:
        int ExecuteObjectArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            ObjectArray* pArr = nullptr;
            std::shared_ptr<void> arrFromType;
            if (!m_Type.empty()) {
                pArr = BuildObjectArray(m_Type);
                arrFromType.reset(pArr);
            }
            else {
                auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
                if (nullptr != obj) {
                    auto* ptr = obj.get();
                    if (nullptr != ptr) {
                        pArr = static_cast<ObjectArray*>(ptr);
                    }
                }
            }
            if (nullptr == pArr)
                return Brace::BRACE_FLOW_CONTROL_NORMAL;
            auto* pNewArr = new ObjectArray();
            std::shared_ptr<void> newArr(pNewArr);
            // where
            ExecuteWhere(gvars, lvars, pArr, pNewArr);
            // orderby
            ExecuteOrderBy(gvars, lvars, pNewArr);
            // groupby
            if (m_GroupIteratorIndex != INVALID_INDEX) {
                std::vector<ObjectArray> groups{};
                ExecuteGroupBy(gvars, lvars, pNewArr, groups);
                return ExecuteGroupSelect(gvars, lvars, groups);
            }
            else {
                return ExecuteSelect(gvars, lvars, pNewArr);
            }
        }
        ObjectArray* BuildObjectArray(const std::string& className)const
        {
            UClass* pClass = FindObject<UClass>(ANY_PACKAGE, UTF8_TO_TCHAR(className.c_str()));
            if (nullptr != pClass) {
                TArray<UObject*> results;
                GetObjectsOfClass(pClass, results);
                auto* p = new ObjectArray();
                for (auto* pObj : results) {
                    std::shared_ptr<void> ptr = std::make_shared<UObjectBraceObject>(pObj);
                    p->push_back(std::move(ptr));
                }
                return p;
            }
            return nullptr;
        }
        void ExecuteWhere(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const ObjectArray* pArr, ObjectArray* pNewArr)const
        {
            if (m_WhereIteratorIndex != INVALID_INDEX) {
                for (auto&& val : (*pArr)) {
                    Brace::VarSetObject(lvars, m_WhereIteratorIndex, val);
                    if (!m_WhereArg.isNull())
                        m_WhereArg(gvars, lvars);
                    bool v = Brace::VarGetBoolean((m_WhereArgInfo.IsGlobal ? gvars : lvars), m_WhereArgInfo.Type, m_WhereArgInfo.VarIndex);
                    if (v)
                        pNewArr->push_back(val);
                }
                FreeObjVars(lvars, m_WhereObjVars);
            }
            else {
                for (auto&& val : (*pArr)) {
                    pNewArr->push_back(val);
                }
            }
        }
        void ExecuteOrderBy(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, ObjectArray* pNewArr)const
        {
            if (m_OrderIteratorIndex != INVALID_INDEX) {
                std::vector<CmpVal> sortVals{};
                std::sort(pNewArr->begin(), pNewArr->end(), [&](auto& e1, auto& e2) {
                    Brace::VarSetObject(lvars, m_OrderIteratorIndex, e1);
                    for (auto&& arg : m_OrderArgs) {
                        if (!arg.isNull())
                            arg(gvars, lvars);
                    }
                    sortVals.clear();
                    for (auto&& argInfo : m_OrderArgInfos) {
                        CmpVal cv;
                        if (Brace::IsStringType(argInfo.Type))
                            cv.StrVal = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        else
                            cv.NumVal = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
                        sortVals.push_back(cv);
                    }
                    Brace::VarSetObject(lvars, m_OrderIteratorIndex, e2);
                    for (auto&& arg : m_OrderArgs) {
                        if (!arg.isNull())
                            arg(gvars, lvars);
                    }
                    int ix = 0;
                    for (auto&& argInfo : m_OrderArgInfos) {
                        bool asc = m_OrderAscs[ix];
                        const CmpVal& cv = sortVals[ix++];
                        if (Brace::IsStringType(argInfo.Type)) {
                            const std::string& v2 = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                            if (asc) {
                                if (cv.StrVal < v2)
                                    return true;
                                else if (cv.StrVal > v2)
                                    return false;
                            }
                            else {
                                if (cv.StrVal > v2)
                                    return true;
                                else if (cv.StrVal < v2)
                                    return false;
                            }
                        }
                        else {
                            double v2 = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
                            if (asc) {
                                if (cv.NumVal < v2)
                                    return true;
                                else if (cv.NumVal > v2)
                                    return false;
                            }
                            else {
                                if (cv.NumVal > v2)
                                    return true;
                                else if (cv.NumVal < v2)
                                    return false;
                            }
                        }
                    }
                    return false;
                });
                FreeObjVars(lvars, m_OrderObjVars);
            }
        }
        void ExecuteGroupBy(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, ObjectArray* pNewArr, std::vector<ObjectArray>& groups)const
        {
            std::vector<CmpVal> groupVals{};
            auto& arr = *pNewArr;
            for (auto&& optr : arr) {
                Brace::VarSetObject(lvars, m_GroupIteratorIndex, optr);
                for (auto&& arg : m_GroupArgs) {
                    if (!arg.isNull())
                        arg(gvars, lvars);
                }
                bool newGroup = false;
                if (groupVals.empty()) {
                    newGroup = true;
                    for (auto&& argInfo : m_GroupArgInfos) {
                        CmpVal cv;
                        if (Brace::IsStringType(argInfo.Type))
                            cv.StrVal = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        else
                            cv.NumVal = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
                        groupVals.push_back(cv);
                    }
                }
                else {
                    int ix = 0;
                    for (auto&& argInfo : m_GroupArgInfos) {
                        CmpVal& cv = groupVals[ix++];
                        if (Brace::IsStringType(argInfo.Type)) {
                            const std::string& v2 = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                            if (cv.StrVal != v2) {
                                newGroup = true;
                                cv.StrVal = v2;
                            }
                        }
                        else {
                            double v2 = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
                            if (cv.NumVal < v2 - DBL_EPSILON || cv.NumVal > v2 + DBL_EPSILON) {
                                newGroup = true;
                                cv.NumVal = v2;
                            }
                        }
                    }
                }
                if (newGroup) {
                    ObjectArray ng;
                    ng.push_back(optr);
                    groups.push_back(std::move(ng));
                }
                else {
                    groups.back().push_back(optr);
                }
            }
            FreeObjVars(lvars, m_GroupObjVars);
        }
        int ExecuteGroupSelect(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<ObjectArray>& groups)const
        {
            // top
            int64_t topn = -1;
            if (m_TopArgInfo.VarIndex != INVALID_INDEX) {
                if (!m_TopArg.isNull())
                    m_TopArg(gvars, lvars);
                topn = Brace::VarGetI64((m_TopArgInfo.IsGlobal ? gvars : lvars), m_TopArgInfo.Type, m_TopArgInfo.VarIndex);
                FreeObjVars(lvars, m_TopObjVars);
            }
            // select and having
            if (m_SelectIteratorIndex != INVALID_INDEX) {
                if (m_Statements.size() > 0) {
                    std::vector<CmpVal> selectVals{};
                    int64_t resultCount = 0;
                    for (auto&& group : groups) {
                        if (!ExecuteGroupStatAndHaving(gvars, lvars, group, selectVals)) {
                            continue;
                        }
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                        FreeObjVars(lvars, m_SelectObjVars);
                        FreeObjVars(lvars, m_ObjVars);
                        ++resultCount;
                        if (topn > 0 && resultCount >= topn)
                            break;
                    }
                }
                else {
                    //same as csvecho
                    std::vector<CmpVal> selectVals{};
                    std::stringstream ss;
                    int64_t resultCount = 0;
                    for (auto&& group : groups) {
                        if (!ExecuteGroupStatAndHaving(gvars, lvars, group, selectVals)) {
                            continue;
                        }
                        ss.str(std::string());
                        bool first = true;
                        for (auto&& cv : selectVals) {
                            bool needQuote = false;
                            if (cv.IsStr && cv.StrVal.length() > 0 && cv.StrVal[0] != '"' && cv.StrVal[0] != '\'') {
                                for (auto c : cv.StrVal) {
                                    if (c == ' ' || c == '\t') {
                                        needQuote = true;
                                        break;
                                    }
                                }
                            }
                            if (first) {
                                first = false;
                            }
                            else {
                                ss << ", ";
                            }
                            if (needQuote)
                                ss << '"' << cv.StrVal << '"';
                            else if (cv.IsStr)
                                ss << cv.StrVal;
                            else
                                ss << std::fixed << std::setprecision(3) << cv.NumVal;
                        }
                        LogInfo(ss.str());
                        LogToDebug(UTF8_TO_TCHAR(ss.str().c_str()));
                        FreeObjVars(lvars, m_SelectObjVars);
                        if (m_HavingArgInfo.VarIndex != INVALID_INDEX) {
                            FreeObjVars(lvars, m_ObjVars);
                        }
                        ++resultCount;
                        if (topn > 0 && resultCount >= topn)
                            break;
                    }
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        bool ExecuteGroupStatAndHaving(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const ObjectArray& group, std::vector<CmpVal>& selectVals)const
        {
            selectVals.clear();
            bool first = true;
            for (auto&& optr : group) {
                Brace::VarSetObject(lvars, m_SelectIteratorIndex, optr);
                for (auto&& arg : m_SelectArgs) {
                    if (!arg.isNull())
                        arg(gvars, lvars);
                }
                bool update = false;
                int six = 0;
                for (auto&& argInfo : m_SelectArgInfos) {
                    int stat = m_SelectStats[six];
                    bool isStr = false;
                    std::string str{};
                    double val{};
                    if (Brace::IsObjectType(argInfo.Type)) {
                        auto& ptr = Brace::VarGetObject((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        switch (argInfo.ObjectTypeId) {
                        case CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT: {
                            auto* p = static_cast<UObjectBraceObject*>(ptr.get());
                            if (p && p->GetImpl()) {
                                UObject* pObj = p->GetImpl();
                                str = TCHAR_TO_UTF8(*pObj->GetFullName());
                            }
                        }break;
                        }
                        isStr = true;
                    }
                    else if (Brace::IsStringType(argInfo.Type)) {
                        str = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                        isStr = true;
                    }
                    else {
                        val = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
                    }
                    if (first) {
                        CmpVal cv;
                        cv.IsStr = isStr;
                        if (isStr) {
                            switch (stat) {
                            case STAT_METHOD_NONE:
                                cv.StrVal = str;
                                break;
                            case STAT_METHOD_MAX:
                                cv.StrVal = str;
                                break;
                            case STAT_METHOD_MIN:
                                cv.StrVal = str;
                                break;
                            case STAT_METHOD_AVG:
                                break;
                            case STAT_METHOD_SUM:
                                break;
                            case STAT_METHOD_COUNT:
                                cv.IsStr = false;
                                cv.NumVal = 1;
                                break;
                            }
                        }
                        else {
                            switch (stat) {
                            case STAT_METHOD_NONE:
                                cv.NumVal = val;
                                break;
                            case STAT_METHOD_MAX:
                                cv.NumVal = val;
                                break;
                            case STAT_METHOD_MIN:
                                cv.NumVal = val;
                                break;
                            case STAT_METHOD_AVG:
                                cv.NumVal = val;
                                break;
                            case STAT_METHOD_SUM:
                                cv.NumVal = val;
                                break;
                            case STAT_METHOD_COUNT:
                                cv.NumVal = 1;
                                break;
                            }
                        }
                        selectVals.push_back(std::move(cv));
                    }
                    else {
                        CmpVal& cv = selectVals[six];
                        if (isStr) {
                            switch (stat) {
                            case STAT_METHOD_NONE:
                                cv.NewStrVal = str;
                                break;
                            case STAT_METHOD_MAX:
                                if (cv.StrVal < str) {
                                    cv.StrVal = str;
                                    update = true;
                                }
                                break;
                            case STAT_METHOD_MIN:
                                if (cv.StrVal > str) {
                                    cv.StrVal = str;
                                    update = true;
                                }
                                break;
                            case STAT_METHOD_AVG:
                                break;
                            case STAT_METHOD_SUM:
                                break;
                            case STAT_METHOD_COUNT:
                                cv.NumVal = cv.NumVal + 1;
                                break;
                            }
                        }
                        else {
                            switch (stat) {
                            case STAT_METHOD_NONE:
                                cv.NewNumVal = val;
                                break;
                            case STAT_METHOD_MAX:
                                if (cv.NumVal < val) {
                                    cv.NumVal = val;
                                    update = true;
                                }
                                break;
                            case STAT_METHOD_MIN:
                                if (cv.NumVal > val) {
                                    cv.NumVal = val;
                                    update = true;
                                }
                                break;
                            case STAT_METHOD_AVG:
                                cv.NumVal = cv.NumVal + val;
                                break;
                            case STAT_METHOD_SUM:
                                cv.NumVal = cv.NumVal + val;
                                break;
                            case STAT_METHOD_COUNT:
                                cv.NumVal = cv.NumVal + 1;
                                break;
                            }
                        }
                    }
                    ++six;
                }
                if (update) {
                    six = 0;
                    for (auto&& cv : selectVals) {
                        int stat = m_SelectStats[six++];
                        if (stat == STAT_METHOD_NONE) {
                            if (cv.IsStr)
                                cv.StrVal = cv.NewStrVal;
                            else
                                cv.NumVal = cv.NewNumVal;
                        }
                    }
                }
                first = false;
            }
            int vix = 0;
            for (auto&& cv : selectVals) {
                int stat = m_SelectStats[vix];
                auto& itInfo = m_Iterators[vix++];
                if (stat == STAT_METHOD_AVG) {
                    cv.NumVal /= group.size();
                }
                if (Brace::IsStringType(itInfo.Type))
                    Brace::VarSetString(lvars, itInfo.VarIndex, cv.StrVal);
                else
                    Brace::VarSetF64(lvars, itInfo.Type, itInfo.VarIndex, cv.NumVal);
            }
            if (m_HavingArgInfo.VarIndex != INVALID_INDEX) {
                if (!m_HavingArg.isNull())
                    m_HavingArg(gvars, lvars);
                bool v = Brace::VarGetBoolean((m_HavingArgInfo.IsGlobal ? gvars : lvars), m_HavingArgInfo.Type, m_HavingArgInfo.VarIndex);
                if (!v) {
                    FreeObjVars(lvars, m_SelectObjVars);
                    return false;
                }
            }
            return true;
        }
        int ExecuteSelect(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, ObjectArray* pNewArr)const
        {
            // top
            if (m_TopArgInfo.VarIndex != INVALID_INDEX) {
                if (!m_TopArg.isNull())
                    m_TopArg(gvars, lvars);
                int64_t n = Brace::VarGetI64((m_TopArgInfo.IsGlobal ? gvars : lvars), m_TopArgInfo.Type, m_TopArgInfo.VarIndex);
                auto& arr = *pNewArr;
                if (static_cast<int64_t>(arr.size()) > n) {
                    auto it = arr.begin();
                    std::advance(it, n);
                    arr.erase(it, arr.end());
                }
                FreeObjVars(lvars, m_TopObjVars);
            }
            // select
            if (m_SelectIteratorIndex != INVALID_INDEX) {
                if (m_Statements.size() > 0) {
                    auto& arr = *pNewArr;
                    for (auto&& optr : arr) {
                        Brace::VarSetObject(lvars, m_SelectIteratorIndex, optr);
                        for (auto&& arg : m_SelectArgs) {
                            if (!arg.isNull())
                                arg(gvars, lvars);
                        }
                        int itIndex = 0;
                        for (auto&& argInfo : m_SelectArgInfos) {
                            int vix = m_Iterators[itIndex].VarIndex;
                            auto* fptr = m_IteratorAssigns[itIndex++];
                            (*fptr)(lvars, vix, lvars, argInfo.VarIndex);
                        }
                        for (auto&& statement : m_Statements) {
                            int v = statement(gvars, lvars);
                            if (IsForceQuit()) {
                                FreeObjVars(lvars, m_SelectObjVars);
                                FreeObjVars(lvars, m_ObjVars);
                                return v;
                            }
                            if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                                break;
                            }
                            else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                                FreeObjVars(lvars, m_SelectObjVars);
                                FreeObjVars(lvars, m_ObjVars);
                                if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                                    return Brace::BRACE_FLOW_CONTROL_NORMAL;
                                return v;
                            }
                        }
                        FreeObjVars(lvars, m_SelectObjVars);
                        FreeObjVars(lvars, m_ObjVars);
                    }
                }
                else {
                    //same as csvecho
                    auto& arr = *pNewArr;
                    for (auto&& optr : arr) {
                        Brace::VarSetObject(lvars, m_SelectIteratorIndex, optr);
                        for (auto&& arg : m_SelectArgs) {
                            if (!arg.isNull())
                                arg(gvars, lvars);
                        }
                        std::stringstream ss;
                        bool first = true;
                        for (auto&& argInfo : m_SelectArgInfos) {
                            std::string str;
                            if (Brace::IsObjectType(argInfo.Type)) {
                                auto& ptr = Brace::VarGetObject((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
                                switch (argInfo.ObjectTypeId) {
                                case CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT: {
                                    auto* p = static_cast<UObjectBraceObject*>(ptr.get());
                                    if (p && p->GetImpl()) {
                                        UObject* pObj = p->GetImpl();
                                        str = TCHAR_TO_UTF8(*pObj->GetFullName());
                                    }
                                }break;
                                }
                            }
                            else if (Brace::IsFloatType(argInfo.Type)) {
                                double dv;
                                if (argInfo.IsGlobal)
                                    dv = Brace::VarGetF64(gvars, argInfo.Type, argInfo.VarIndex);
                                else
                                    dv = Brace::VarGetF64(lvars, argInfo.Type, argInfo.VarIndex);
                                std::stringstream tss;
                                tss << std::fixed << std::setprecision(3) << dv;
                                str = tss.str();
                            }
                            else {
                                if (argInfo.IsGlobal)
                                    str = Brace::VarGetStr(gvars, argInfo.Type, argInfo.VarIndex);
                                else
                                    str = Brace::VarGetStr(lvars, argInfo.Type, argInfo.VarIndex);
                            }
                            bool needQuote = false;
                            if (str.length() > 0 && str[0] != '"' && str[0] != '\'') {
                                for (auto c : str) {
                                    if (c == ' ' || c == '\t') {
                                        needQuote = true;
                                        break;
                                    }
                                }
                            }
                            if (first) {
                                first = false;
                            }
                            else {
                                ss << ", ";
                            }
                            if (needQuote)
                                ss << '"' << str << '"';
                            else
                                ss << str;
                        }
                        LogInfo(ss.str());
                        LogToDebug(UTF8_TO_TCHAR(ss.str().c_str()));
                        FreeObjVars(lvars, m_SelectObjVars);
                    }
                }
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    private:
        std::string m_Type;
        Brace::BraceApiExecutor m_List;
        Brace::OperandRuntimeInfo m_ListInfo;

        int m_SelectIteratorIndex;
        std::vector<Brace::OperandRuntimeInfo> m_SelectArgInfos;
        std::vector<Brace::BraceApiExecutor> m_SelectArgs;
        std::vector<int> m_SelectStats;
        std::vector<int> m_SelectObjVars;

        Brace::OperandRuntimeInfo m_TopArgInfo;
        Brace::BraceApiExecutor m_TopArg;
        std::vector<int> m_TopObjVars;

        int m_WhereIteratorIndex;
        Brace::OperandRuntimeInfo m_WhereArgInfo;
        Brace::BraceApiExecutor m_WhereArg;
        std::vector<int> m_WhereObjVars;

        int m_OrderIteratorIndex;
        std::vector<Brace::OperandRuntimeInfo> m_OrderArgInfos;
        std::vector<Brace::BraceApiExecutor> m_OrderArgs;
        std::vector<bool> m_OrderAscs;
        std::vector<int> m_OrderObjVars;

        int m_GroupIteratorIndex;
        std::vector<Brace::OperandRuntimeInfo> m_GroupArgInfos;
        std::vector<Brace::BraceApiExecutor> m_GroupArgs;
        std::vector<int> m_GroupObjVars;

        std::vector<Brace::OperandRuntimeInfo> m_Iterators;
        std::vector<Brace::VarAssignPtr> m_IteratorAssigns;

        Brace::OperandRuntimeInfo m_HavingArgInfo;
        Brace::BraceApiExecutor m_HavingArg;

        std::vector<Brace::BraceApiExecutor> m_Statements;
        std::vector<int> m_ObjVars;
    };

    class StringMemberCallProvider final : public AbstractMemberCallApiProvider
    {
        friend class MemberCallExp;
    protected:
        virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
        {
            std::swap(m_Obj, obj);
            m_ObjInfo = objInfo;
            std::swap(m_Member, member);
            std::swap(m_Args, args);
            for (auto&& argInfo : argInfos) {
                m_ArgInfos.push_back(argInfo);
            }
            auto& m = m_Member;
            if (m == "ReplaceAll") {
                if (argInfos.size() == 2) {
                    auto& argInfo = argInfos[0];
                    auto& argInfo2 = argInfos[1];
                    if (Brace::IsStringType(argInfo.Type) && Brace::IsStringType(argInfo2.Type)) {
                        resultInfo = objInfo;
                        executor.attach(this, &StringMemberCallProvider::ExecuteReplaceAll);
                        return true;
                    }
                }
                std::stringstream ss;
                ss << "expected String.ReplaceAll(string, string) ! line: " << data.GetLine();
                LogError(ss.str());
                return false;
            }
            return false;
        }
    private:
        int ExecuteReplaceAll(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_Obj.isNull())
                m_Obj(gvars, lvars);
            for (auto&& _arg : m_Args) {
                if (!_arg.isNull())
                    _arg(gvars, lvars);
            }
            auto& strInfo = m_ObjInfo;
            auto& strInfo1 = m_ArgInfos[0];
            auto& strInfo2 = m_ArgInfos[1];
            std::string& str = Brace::VarGetString((strInfo.IsGlobal ? gvars : lvars), strInfo.VarIndex);
            const std::string& what = Brace::VarGetString((strInfo1.IsGlobal ? gvars : lvars), strInfo1.VarIndex);
            const std::string& with = Brace::VarGetString((strInfo2.IsGlobal ? gvars : lvars), strInfo2.VarIndex);
            for (std::string::size_type pos{}; str.npos != (pos = str.find(what.data(), pos, what.length())); pos += with.length()) {
                str.replace(pos, what.length(), with.data(), with.length());
            }
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    private:
        StringMemberCallProvider(Brace::BraceScript& interpreter) :AbstractMemberCallApiProvider(interpreter), m_Obj(), m_ObjInfo(), m_Member(), m_Args(), m_ArgInfos(), m_ResultInfo()
        {
        }
    private:
        Brace::BraceApiExecutor m_Obj;
        Brace::OperandRuntimeInfo m_ObjInfo;
        std::string m_Member;
        std::vector<Brace::BraceApiExecutor> m_Args;
        std::vector<Brace::OperandRuntimeInfo> m_ArgInfos;
        Brace::OperandRuntimeInfo m_ResultInfo;
    };
    class StringMemberSetProvider final : public AbstractMemberSetApiProvider
    {
        friend class MemberSetExp;
    protected:
        virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
        {
            return false;
        }
    private:
        StringMemberSetProvider(Brace::BraceScript& interpreter) :AbstractMemberSetApiProvider(interpreter)
        {}
    };
    class StringMemberGetProvider final : public AbstractMemberGetApiProvider
    {
        friend class MemberGetExp;
    protected:
        virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
        {
            return false;
        }
    private:
        StringMemberGetProvider(Brace::BraceScript& interpreter) :AbstractMemberGetApiProvider(interpreter)
        {}
    };
    class StringCollectionCallProvider final : public AbstractCollectionCallApiProvider
    {
        friend class CollectionCallExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) const override
        {
            return false;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo) const override
        {
        }
    private:
        StringCollectionCallProvider(Brace::BraceScript& interpreter) :AbstractCollectionCallApiProvider(interpreter)
        {}
    };
    class StringCollectionSetProvider final : public AbstractCollectionSetApiProvider
    {
        friend class CollectionSetExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, const Brace::OperandLoadtimeInfo& val, Brace::OperandLoadtimeInfo& resultInfo) const override
        {
            if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
                std::stringstream ss;
                ss << "String's index must be integer ! line: " << data.GetLine();
                LogError(ss.str());
                return false;
            }
            if (!CanAssign(Brace::BRACE_DATA_TYPE_UINT8, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, val.Type, val.ObjectTypeId)) {
                std::stringstream ss;
                ss << "String element's type and val type dismatch ! line: " << data.GetLine();
                LogError(ss.str());
                return false;
            }
            resultInfo = val;
            return true;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& val, const Brace::OperandRuntimeInfo& resultInfo) const override
        {
            std::string& str = Brace::VarGetString((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
            int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
            uint64_t v = Brace::VarGetU64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
            if (vix >= 0 && vix < static_cast<int64_t>(str.length())) {
                str.replace(static_cast<size_t>(vix), 1, 1, static_cast<char>(static_cast<uint8_t>(v)));
            }
        }
    private:
        StringCollectionSetProvider(Brace::BraceScript& interpreter) :AbstractCollectionSetApiProvider(interpreter)
        {}
    };
    class StringCollectionGetProvider final : public AbstractCollectionGetApiProvider
    {
        friend class CollectionGetExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, Brace::OperandLoadtimeInfo& resultInfo) const override
        {
            if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
                std::stringstream ss;
                ss << "String's index must be integer ! line: " << data.GetLine();
                LogError(ss.str());
                return false;
            }
            resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT8;
            resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
            resultInfo.Name = GenTempVarName();
            resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
            return true;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& resultInfo) const override
        {
            const std::string& str = Brace::VarGetString((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
            int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
            char v = 0;
            if (vix >= 0 && vix < static_cast<int64_t>(str.length())) {
                v = str[vix];
            }
            Brace::VarSetUInt8((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, static_cast<uint8_t>(v));
        }
    private:
        StringCollectionGetProvider(Brace::BraceScript& interpreter) :AbstractCollectionGetApiProvider(interpreter)
        {}
    };
    class StringLoopListProvider final : public AbstractLoopListApiProvider
    {
        friend class LoopListExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::ISyntaxComponent& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor) override
        {
            return TypeInference(listInfo, executor);
        }
        virtual void StoreRuntimeInfo(Brace::OperandRuntimeInfo&& listInfo, Brace::BraceApiExecutor&& list, std::vector<Brace::BraceApiExecutor>&& statements, const std::vector<int>& objVars) override
        {
            std::swap(m_ListInfo, listInfo);
            std::swap(m_List, list);
            std::swap(m_Statements, statements);
            m_ObjVars = objVars;
        }
    private:
        StringLoopListProvider(Brace::BraceScript& interpreter) :AbstractLoopListApiProvider(interpreter), m_IteratorIndex(INVALID_INDEX), m_List(), m_ListInfo(), m_Statements(), m_ObjVars()
        {}
    private:
        bool TypeInference(const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor)
        {
            if (listInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
                m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_UINT8, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
                executor.attach(this, &StringLoopListProvider::Execute);
                return true;
            }
            return false;
        }
        int Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            if (!m_List.isNull())
                m_List(gvars, lvars);
            auto& str = Brace::VarGetString((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
            for (char val : str) {
                Brace::VarSetUInt8(lvars, m_IteratorIndex, static_cast<uint8_t>(val));
                for (auto&& statement : m_Statements) {
                    int v = statement(gvars, lvars);
                    if (IsForceQuit()) {
                        FreeObjVars(lvars, m_ObjVars);
                        return v;
                    }
                    if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                        break;
                    }
                    else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                        FreeObjVars(lvars, m_ObjVars);
                        if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                            return Brace::BRACE_FLOW_CONTROL_NORMAL;
                        return v;
                    }
                }
            }
            FreeObjVars(lvars, m_ObjVars);
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    private:
        int m_IteratorIndex;
        Brace::BraceApiExecutor m_List;
        Brace::OperandRuntimeInfo m_ListInfo;
        std::vector<Brace::BraceApiExecutor> m_Statements;
        std::vector<int> m_ObjVars;
    };

    class MemberCallExp final : public Brace::AbstractBraceApi
    {
    public:
        MemberCallExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ApiProvider()
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            int num = data.GetParamNum();
            if (num < 2)
                return false;
            Brace::OperandLoadtimeInfo loadInfo;
            auto obj = LoadHelper(*data.GetParam(0), loadInfo);
            auto& objInfo = loadInfo;
            auto& m = data.GetParamId(1);
            auto member = m;
            std::vector<Brace::OperandLoadtimeInfo> argInfos;
            std::vector<Brace::BraceApiExecutor> args;
            Brace::OperandLoadtimeInfo firstArgInfo;
            for (int ix = 2; ix < num; ++ix) {
                auto* param = data.GetParam(ix);
                Brace::OperandLoadtimeInfo argLoadInfo;
                auto p = LoadHelper(*param, argLoadInfo);
                args.push_back(std::move(p));
                argInfos.push_back(argLoadInfo);
                if (ix == 2)
                    firstArgInfo = std::move(argLoadInfo);
            }
            if (objInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(loadInfo.ObjectTypeId);
                if (nullptr != pInfo) {
                    AbstractMemberCallApiProvider* pProvider = nullptr;
                    switch (pInfo->ObjectCategory) {
                    case BRACE_OBJECT_CATEGORY_UOBJECT:
                        pProvider = new UObjectMemberCallProvider(GetInterpreter());
                        break;
                    case BRACE_OBJECT_CATEGORY_STRUCT:
                        pProvider = new StructMemberCallProvider(GetInterpreter());
                        break;
                    default:
                        pProvider = new ArrayHashtableMemberCallProvider(GetInterpreter());
                        break;
                    }
                    if (pProvider) {
                        m_ApiProvider.reset(pProvider);
                        return pProvider->LoadMemberCall(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), std::move(argInfos), std::move(args), resultInfo, executor);
                    }
                }
            }
            else if (objInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
                if (nullptr != pInfo) {
                    AbstractMemberCallApiProvider* pProvider = new StringMemberCallProvider(GetInterpreter());
                    if (pProvider) {
                        m_ApiProvider.reset(pProvider);
                        return pProvider->LoadMemberCall(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), std::move(argInfos), std::move(args), resultInfo, executor);
                    }
                }
            }
            std::stringstream ss;
            ss << "Unknown member " << m << " line: " << data.GetLine();
            LogError(ss.str());
            executor = nullptr;
            return false;
        }
    private:
        std::unique_ptr<AbstractMemberCallApiProvider> m_ApiProvider;
    };
    class MemberSetExp final : public Brace::AbstractBraceApi
    {
    public:
        MemberSetExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ApiProvider()
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            if (data.GetParamNum() != 3)
                return false;
            Brace::OperandLoadtimeInfo loadInfo;
            auto obj = LoadHelper(*data.GetParam(0), loadInfo);
            auto& objInfo = loadInfo;
            auto& m = data.GetParamId(1);
            auto member = m;
            auto* param = data.GetParam(2);
            Brace::OperandLoadtimeInfo argLoadInfo;
            auto p = LoadHelper(*param, argLoadInfo);
            if (objInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(loadInfo.ObjectTypeId);
                if (nullptr != pInfo) {
                    AbstractMemberSetApiProvider* pProvider = nullptr;
                    switch (pInfo->ObjectCategory) {
                    case BRACE_OBJECT_CATEGORY_UOBJECT:
                        pProvider = new UObjectMemberSetProvider(GetInterpreter());
                        break;
                    case BRACE_OBJECT_CATEGORY_STRUCT:
                        pProvider = new StructMemberSetProvider(GetInterpreter());
                        break;
                    default:
                        pProvider = new ArrayHashtableMemberSetProvider(GetInterpreter());
                        break;
                    }
                    if (pProvider) {
                        m_ApiProvider.reset(pProvider);
                        return pProvider->LoadMemberSet(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), std::move(argLoadInfo), std::move(p), resultInfo, executor);
                    }
                }
            }
            else if (objInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
                if (nullptr != pInfo) {
                    AbstractMemberSetApiProvider* pProvider = new StringMemberSetProvider(GetInterpreter());
                    if (pProvider) {
                        m_ApiProvider.reset(pProvider);
                        return pProvider->LoadMemberSet(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), std::move(argLoadInfo), std::move(p), resultInfo, executor);
                    }
                }
            }
            executor = nullptr;
            return true;
        }
    private:
        std::unique_ptr<AbstractMemberSetApiProvider> m_ApiProvider;
    };
    class MemberGetExp final : public Brace::AbstractBraceApi
    {
    public:
        MemberGetExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ApiProvider()
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            if (data.GetParamNum() != 2)
                return false;
            Brace::OperandLoadtimeInfo loadInfo;
            auto obj = LoadHelper(*data.GetParam(0), loadInfo);
            auto& objInfo = loadInfo;
            auto& m = data.GetParamId(1);
            auto member = m;
            if (objInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(loadInfo.ObjectTypeId);
                if (nullptr != pInfo) {
                    AbstractMemberGetApiProvider* pProvider = nullptr;
                    switch (pInfo->ObjectCategory) {
                    case BRACE_OBJECT_CATEGORY_UOBJECT:
                        pProvider = new UObjectMemberGetProvider(GetInterpreter());
                        break;
                    case BRACE_OBJECT_CATEGORY_STRUCT:
                        pProvider = new StructMemberGetProvider(GetInterpreter());
                        break;
                    default:
                        pProvider = new ArrayHashtableMemberGetProvider(GetInterpreter());
                        break;
                    }
                    if (pProvider) {
                        m_ApiProvider.reset(pProvider);
                        return pProvider->LoadMemberGet(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), resultInfo, executor);
                    }
                }
            }
            else if (objInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
                if (nullptr != pInfo) {
                    AbstractMemberGetApiProvider* pProvider = new StringMemberGetProvider(GetInterpreter());
                    if (pProvider) {
                        m_ApiProvider.reset(pProvider);
                        return pProvider->LoadMemberGet(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), resultInfo, executor);
                    }
                }
            }
            std::stringstream ss;
            ss << "Unknown member " << m << " line: " << data.GetLine();
            LogError(ss.str());
            return false;
        }
    private:
        std::unique_ptr<AbstractMemberGetApiProvider> m_ApiProvider;
    };
    class CollectionCallExp final : public Brace::SimpleBraceApiBase
    {
    public:
        CollectionCallExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter), m_ApiProvider()
        {
        }
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
        {
            /// how to interpret this, f = obj[m] and f(args) or obj[m](obj, args) ?
            if (argInfos.size() < 2)
                return false;
            auto& arr = argInfos[0];
            if (arr.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(arr.ObjectTypeId);
                if (nullptr != pInfo) {
                    AbstractCollectionCallApiProvider* pProvider = nullptr;
                    switch (pInfo->ObjectCategory) {
                    case BRACE_OBJECT_CATEGORY_UOBJECT:
                    case BRACE_OBJECT_CATEGORY_ACTOR:
                    default:
                        pProvider = new ArrayHashtableCollectionCallProvider(GetInterpreter());
                        break;
                    }
                    if (pProvider) {
                        m_ApiProvider.reset(pProvider);
                        return pProvider->TypeInference(func, data, *pInfo, argInfos, resultInfo);
                    }
                }
            }
            else if (arr.Type == Brace::BRACE_DATA_TYPE_STRING) {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
                if (nullptr != pInfo) {
                    AbstractCollectionCallApiProvider* pProvider = new StringCollectionCallProvider(GetInterpreter());
                    if (pProvider) {
                        m_ApiProvider.reset(pProvider);
                        return pProvider->TypeInference(func, data, *pInfo, argInfos, resultInfo);
                    }
                }
            }
            return false;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
        {
            /// how to interpret this, f = obj[m] and f(args) or obj[m](obj, args) ?
            m_ApiProvider->Execute(gvars, lvars, argInfos, resultInfo);
        }
    private:
        std::unique_ptr<AbstractCollectionCallApiProvider> m_ApiProvider;
    };
    class CollectionSetExp final : public Brace::SimpleBraceApiBase
    {
    public:
        CollectionSetExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter), m_ApiProvider()
        {
        }
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
        {
            if (argInfos.size() != 3)
                return false;
            auto& arr = argInfos[0];
            auto& ix = argInfos[1];
            auto& val = argInfos[2];
            if (arr.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(arr.ObjectTypeId);
                if (nullptr != pInfo) {
                    AbstractCollectionSetApiProvider* pProvider = nullptr;
                    switch (pInfo->ObjectCategory) {
                    case BRACE_OBJECT_CATEGORY_UOBJECT:
                    case BRACE_OBJECT_CATEGORY_ACTOR:
                    default:
                        pProvider = new ArrayHashtableCollectionSetProvider(GetInterpreter());
                        break;
                    }
                    if (pProvider) {
                        m_ApiProvider.reset(pProvider);
                        return pProvider->TypeInference(func, data, *pInfo, arr, ix, val, resultInfo);
                    }
                }
            }
            else if (arr.Type == Brace::BRACE_DATA_TYPE_STRING) {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
                if (nullptr != pInfo) {
                    AbstractCollectionSetApiProvider* pProvider = new StringCollectionSetProvider(GetInterpreter());
                    if (pProvider) {
                        m_ApiProvider.reset(pProvider);
                        return pProvider->TypeInference(func, data, *pInfo, arr, ix, val, resultInfo);
                    }
                }
            }
            std::stringstream ss;
            ss << "Unknown collection type ! line: " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
        {
            auto& arr = argInfos[0];
            auto& ix = argInfos[1];
            auto& val = argInfos[2];
            m_ApiProvider->Execute(gvars, lvars, arr, ix, val, resultInfo);
        }
    private:
        std::unique_ptr<AbstractCollectionSetApiProvider> m_ApiProvider;
    };
    class CollectionGetExp final : public Brace::SimpleBraceApiBase
    {
    public:
        CollectionGetExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter), m_ApiProvider()
        {
        }
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
        {
            if (argInfos.size() != 2)
                return false;
            auto& arr = argInfos[0];
            auto& ix = argInfos[1];
            if (arr.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(arr.ObjectTypeId);
                if (nullptr != pInfo) {
                    AbstractCollectionGetApiProvider* pProvider = nullptr;
                    switch (pInfo->ObjectCategory) {
                    case BRACE_OBJECT_CATEGORY_UOBJECT:
                    case BRACE_OBJECT_CATEGORY_ACTOR:
                    default:
                        pProvider = new ArrayHashtableCollectionGetProvider(GetInterpreter());
                        break;
                    }
                    if (pProvider) {
                        m_ApiProvider.reset(pProvider);
                        return pProvider->TypeInference(func, data, *pInfo, arr, ix, resultInfo);
                    }
                }
            }
            else if (arr.Type == Brace::BRACE_DATA_TYPE_STRING) {
                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
                if (nullptr != pInfo) {
                    AbstractCollectionGetApiProvider* pProvider = new StringCollectionGetProvider(GetInterpreter());
                    if (pProvider) {
                        m_ApiProvider.reset(pProvider);
                        return pProvider->TypeInference(func, data, *pInfo, arr, ix, resultInfo);
                    }
                }
            }
            std::stringstream ss;
            ss << "Unknown collection type ! line: " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
        {
            auto& arr = argInfos[0];
            auto& ix = argInfos[1];
            m_ApiProvider->Execute(gvars, lvars, arr, ix, resultInfo);
        }
    private:
        std::unique_ptr<AbstractCollectionGetApiProvider> m_ApiProvider;
    };
    class LambdaExp final : public Brace::AbstractBraceApi
    {
    public:
        LambdaExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            //(args) => {...}; or (args)int => {...}; or [...](args) => {...}; or [...](args)int => {...};
            bool hasError = true;
            if (hasError) {
                std::stringstream ss;
                ss << "lambda syntax error, line " << data.GetLine();
                LogError(ss.str());
            }
            return false;
        }
    };
    class LinqExp final : public Brace::AbstractBraceApi
    {
    public:
        LinqExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            //objs.where(condition) => linq(objs, "where", condition)
            //objs.orderby(fields) => linq(objs, "orderby", fields)
            //objs.orderbydesc(fields) => linq(objs, "orderbydesc", fields)
            //objs.top(count) => linq(objs, "top", count)
            int pnum = data.GetParamNum();
            if (pnum > 2) {
                Brace::OperandLoadtimeInfo listInfo;
                Brace::BraceApiExecutor list = LoadHelper(*data.GetParam(0), listInfo);
                std::string mid = data.GetParamId(1);
                BraceObjectInfo* pInfo = nullptr;
                AbstractLinqApiProvider* pProvider = nullptr;
                if (listInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
                    pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(listInfo.ObjectTypeId);
                    if (nullptr != pInfo && pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_OBJ_ARRAY) {
                        pProvider = new ArrayHashtableLinqProvider(GetInterpreter());
                    }
                }
                if (nullptr != pInfo && nullptr != pProvider) {
                    PushBlock();
                    int iteratorIndex = INVALID_INDEX;
                    if (mid != "top") {
                        iteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_OBJECT, pInfo->GetTypeParamObjTypeId(0));
                    }
                    std::vector<Brace::OperandLoadtimeInfo> argInfos;
                    std::vector<Brace::BraceApiExecutor> args;
                    for (int ix = 2; ix < pnum; ++ix) {
                        auto* param = data.GetParam(ix);
                        Brace::OperandLoadtimeInfo argLoadInfo;
                        auto p = LoadHelper(*param, argLoadInfo);
                        argInfos.push_back(std::move(argLoadInfo));
                        args.push_back(std::move(p));
                    }
                    auto objVars = CurBlockObjVars();
                    PopBlock();
                    if (nullptr != pProvider) {
                        bool ret = pProvider->LoadLinqCall(func, data, *pInfo, iteratorIndex, std::move(listInfo), std::move(list), std::move(mid), std::move(argInfos), std::move(args), std::move(objVars), resultInfo, executor);
                        return ret;
                    }
                }
            }
            std::stringstream ss;
            ss << "linq syntax error, line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
    private:
        std::unique_ptr<AbstractLinqApiProvider> m_ApiProvider;
    };
    class SelectExp final : public Brace::AbstractBraceApi
    {
    public:
        SelectExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
        {
        }
    protected:
        virtual bool LoadStatement(const Brace::FuncInfo& func, const DslData::StatementData& statementData, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            //select(fields)top(10)from(objlist)where(exp)oderby(exps)groupby(exps)having(exp){statements;};
            std::string uobjArrKey = "array<:uobject:>";
            int uobjArrTypeId = g_ObjectInfoMgr.GetObjectTypeId(uobjArrKey);

            int fnum = statementData.GetFunctionNum();
            BraceObjectInfo* pInfo = nullptr;
            AbstractSelectApiProvider* pProvider = new ArrayHashtableSelectProvider(GetInterpreter());
            for (int ix = 0; ix < fnum; ++ix) {
                DslData::FunctionData* pFuncData = statementData.GetFunction(ix)->AsFunction();
                if (nullptr != pFuncData) {
                    const std::string& fid = pFuncData->GetId();
                    DslData::FunctionData* pCallData = pFuncData;
                    if (pFuncData->IsHighOrder()) {
                        pCallData = &pFuncData->GetLowerOrderFunction();
                        if (ix != fnum - 1)
                            return false;
                    }
                    if (fid == "from") {
                        DslData::ISyntaxComponent* pSyntax = pCallData->GetParam(0);
                        if (pSyntax->GetSyntaxType() == DslData::ISyntaxComponent::TYPE_VALUE) {
                            pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(uobjArrTypeId);
                            pProvider->LoadFromType(func, *pFuncData, *pInfo, pSyntax->GetId());
                        }
                        else {
                            Brace::OperandLoadtimeInfo listInfo;
                            Brace::BraceApiExecutor list;
                            list = LoadHelper(*pCallData->GetParam(0), listInfo);
                            if (listInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
                                pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(listInfo.ObjectTypeId);
                            }
                            else {
                                pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(uobjArrTypeId);
                            }
                            pProvider->LoadFromList(func, *pCallData, *pInfo, std::move(listInfo), std::move(list));
                        }
                        break;
                    }
                }
            }
            DslData::FunctionData* pHavingCallData = nullptr;
            std::vector<Brace::DataTypeInfo> selectItTypes;
            for (int fix = 0; fix < fnum; ++fix) {
                DslData::FunctionData* pFuncData = statementData.GetFunction(fix)->AsFunction();
                if (nullptr != pFuncData) {
                    const std::string& fid = pFuncData->GetId();
                    DslData::FunctionData* pCallData = pFuncData;
                    if (pFuncData->IsHighOrder()) {
                        pCallData = &pFuncData->GetLowerOrderFunction();
                        if (fix != fnum - 1)
                            return false;
                    }
                    if (fid == "select") {
                        PushBlock();
                        int iteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_OBJECT, nullptr != pInfo ? pInfo->GetTypeParamObjTypeId(0) : CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT);
                        std::vector<Brace::OperandLoadtimeInfo> argInfos;
                        std::vector<Brace::BraceApiExecutor> args;
                        std::vector<int> stats;
                        int pnum = pCallData->GetParamNum();
                        for (int pix = 0; pix < pnum; ++pix) {
                            auto* param = pCallData->GetParam(pix);
                            int stat = AbstractSelectApiProvider::STAT_METHOD_NONE;
                            if (param->GetSyntaxType() == DslData::ISyntaxComponent::TYPE_FUNCTION) {
                                auto* pParamFunc = static_cast<DslData::FunctionData*>(param);
                                const std::string& pid = param->GetId();
                                if (pid == "max") {
                                    stat = AbstractSelectApiProvider::STAT_METHOD_MAX;
                                    param = pParamFunc->GetParam(0);
                                }
                                else if (pid == "min") {
                                    stat = AbstractSelectApiProvider::STAT_METHOD_MIN;
                                    param = pParamFunc->GetParam(0);
                                }
                                else if (pid == "sum") {
                                    stat = AbstractSelectApiProvider::STAT_METHOD_SUM;
                                    param = pParamFunc->GetParam(0);
                                }
                                else if (pid == "avg") {
                                    stat = AbstractSelectApiProvider::STAT_METHOD_AVG;
                                    param = pParamFunc->GetParam(0);
                                }
                                else if (pid == "count") {
                                    stat = AbstractSelectApiProvider::STAT_METHOD_COUNT;
                                    param = pParamFunc->GetParam(0);
                                }
                            }
                            Brace::OperandLoadtimeInfo argLoadInfo;
                            auto p = LoadHelper(*param, argLoadInfo);
                            switch (stat) {
                            case AbstractSelectApiProvider::STAT_METHOD_COUNT:
                                selectItTypes.push_back(Brace::DataTypeInfo(Brace::BRACE_DATA_TYPE_INT32, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ));
                                break;
                            case AbstractSelectApiProvider::STAT_METHOD_NONE:
                            default:
                                selectItTypes.push_back(argLoadInfo);
                                break;
                            }
                            argInfos.push_back(std::move(argLoadInfo));
                            args.push_back(std::move(p));
                            stats.push_back(stat);
                        }
                        auto objVars = CurBlockObjVars();
                        PopBlock();
                        bool ret = pProvider->LoadSelect(func, *pCallData, *pInfo, iteratorIndex, std::move(argInfos), std::move(args), std::move(stats), std::move(objVars));
                        if (!ret)
                            return false;
                    }
                    else if (fid == "top") {
                        PushBlock();
                        Brace::OperandLoadtimeInfo argInfo;
                        Brace::BraceApiExecutor arg;
                        //int pnum = pCallData->GetParamNum();
                        auto* param = pCallData->GetParam(0);
                        arg = LoadHelper(*param, argInfo);
                        auto objVars = CurBlockObjVars();
                        PopBlock();
                        bool ret = pProvider->LoadTop(func, *pCallData, std::move(argInfo), std::move(arg), std::move(objVars));
                        if (!ret)
                            return false;
                    }
                    else if (fid == "from") {

                    }
                    else if (fid == "where") {
                        PushBlock();
                        int iteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_OBJECT, nullptr != pInfo ? pInfo->GetTypeParamObjTypeId(0) : CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT);
                        Brace::OperandLoadtimeInfo argInfo;
                        Brace::BraceApiExecutor arg;
                        //int pnum = pCallData->GetParamNum();
                        auto* param = pCallData->GetParam(0);
                        arg = LoadHelper(*param, argInfo);
                        auto objVars = CurBlockObjVars();
                        PopBlock();
                        bool ret = pProvider->LoadWhere(func, *pCallData, *pInfo, iteratorIndex, std::move(argInfo), std::move(arg), std::move(objVars));
                        if (!ret)
                            return false;
                    }
                    else if (fid == "orderby") {
                        PushBlock();
                        int iteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_OBJECT, nullptr != pInfo ? pInfo->GetTypeParamObjTypeId(0) : CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT);
                        std::vector<Brace::OperandLoadtimeInfo> argInfos;
                        std::vector<Brace::BraceApiExecutor> args;
                        std::vector<bool> ascOrDescs;
                        int pnum = pCallData->GetParamNum();
                        for (int pix = 0; pix < pnum; ++pix) {
                            auto* param = pCallData->GetParam(pix);
                            bool asc = true;
                            if (param->GetSyntaxType() == DslData::ISyntaxComponent::TYPE_FUNCTION && param->GetId() == ":") {
                                auto* pParamFunc = static_cast<DslData::FunctionData*>(param);
                                param = pParamFunc->GetParam(0);
                                asc = pParamFunc->GetParamId(1) != "desc";
                            }
                            Brace::OperandLoadtimeInfo argLoadInfo;
                            auto p = LoadHelper(*param, argLoadInfo);
                            argInfos.push_back(std::move(argLoadInfo));
                            args.push_back(std::move(p));
                            ascOrDescs.push_back(asc);
                        }
                        auto objVars = CurBlockObjVars();
                        PopBlock();
                        bool ret = pProvider->LoadOrderBy(func, *pCallData, *pInfo, iteratorIndex, std::move(argInfos), std::move(args), std::move(ascOrDescs), std::move(objVars));
                        if (!ret)
                            return false;
                    }
                    else if (fid == "groupby") {
                        PushBlock();
                        int iteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_OBJECT, nullptr != pInfo ? pInfo->GetTypeParamObjTypeId(0) : CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT);
                        std::vector<Brace::OperandLoadtimeInfo> argInfos;
                        std::vector<Brace::BraceApiExecutor> args;
                        int pnum = pCallData->GetParamNum();
                        for (int pix = 0; pix < pnum; ++pix) {
                            auto* param = pCallData->GetParam(pix);
                            Brace::OperandLoadtimeInfo argLoadInfo;
                            auto p = LoadHelper(*param, argLoadInfo);
                            argInfos.push_back(std::move(argLoadInfo));
                            args.push_back(std::move(p));
                        }
                        auto objVars = CurBlockObjVars();
                        PopBlock();
                        bool ret = pProvider->LoadGroupBy(func, *pCallData, *pInfo, iteratorIndex, std::move(argInfos), std::move(args), std::move(objVars));
                        if (!ret)
                            return false;
                    }
                    else if (fid == "having") {
                        pHavingCallData = pCallData;
                    }
                    else {
                        return false;
                    }
                    if (fix == fnum - 1) {
                        std::vector<Brace::OperandLoadtimeInfo> iterators;
                        std::vector<Brace::BraceApiExecutor> statements;
                        PushBlock();
                        for (int i = 0; i < static_cast<int>(selectItTypes.size()); ++i) {
                            auto& dt = selectItTypes[i];
                            Brace::OperandLoadtimeInfo itInfo;
                            itInfo.Type = dt.Type;
                            itInfo.ObjectTypeId = dt.ObjectTypeId;
                            itInfo.Name = std::string("$") + std::to_string(i);
                            itInfo.VarIndex = AllocVariable(itInfo.Name, itInfo.Type, itInfo.ObjectTypeId);
                            iterators.push_back(std::move(itInfo));
                        }
                        bool ret = true;
                        if (nullptr != pHavingCallData) {
                            Brace::OperandLoadtimeInfo argInfo;
                            Brace::BraceApiExecutor arg;
                            auto* param = pHavingCallData->GetParam(0);
                            arg = LoadHelper(*param, argInfo);
                            ret = pProvider->LoadHaving(func, *pHavingCallData, std::move(argInfo), std::move(arg));
                        }
                        if (pFuncData->IsHighOrder()) {
                            std::vector<Brace::OperandLoadtimeInfo> argInfos;
                            std::vector<Brace::BraceApiExecutor> args;
                            int pnum = pFuncData->GetParamNum();
                            for (int pix = 0; pix < pnum; ++pix) {
                                auto* param = pFuncData->GetParam(pix);
                                Brace::OperandLoadtimeInfo argLoadInfo;
                                auto p = LoadHelper(*param, argLoadInfo);
                                if (!p.isNull())
                                    statements.push_back(std::move(p));
                            }
                        }
                        auto objVars = CurBlockObjVars();
                        PopBlock();
                        ret = pProvider->LoadStatements(func, *pFuncData, std::move(statements), resultInfo, executor) && ret;
                        pProvider->LoadResultIterator(std::move(iterators), std::move(objVars));
                        if (!ret)
                            return false;
                    }
                }
            }
            return true;
        }
    private:
        std::unique_ptr<AbstractSelectApiProvider> m_ApiProvider;
    };
    class ArrayExp final : public Brace::AbstractBraceApi
    {
        enum ArrayCategory
        {
            ARRAY_UNKNOWN = -1,
            ARRAY_BOOL = 0,
            ARRAY_INT,
            ARRAY_FLOAT,
            ARRAY_STRING,
            ARRAY_OBJ
        };
    public:
        ArrayExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ObjectTypeId(Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ), m_Args(), m_ArgInfos(), m_ResultInfo()
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& curFunc, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)
        {
            std::vector<Brace::BraceApiExecutor> args;
            std::vector<Brace::OperandLoadtimeInfo> argLoadInfos;
            int num = data.GetParamNum();
            for (int ix = 0; ix < num; ++ix) {
                auto* param = data.GetParam(ix);
                Brace::OperandLoadtimeInfo argLoadInfo;
                auto p = LoadHelper(*param, argLoadInfo);
                args.push_back(std::move(p));
                argLoadInfos.push_back(std::move(argLoadInfo));
            }
            int arrayCategory = ARRAY_UNKNOWN;
            int dataType = Brace::BRACE_DATA_TYPE_UNKNOWN;
            int objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
            if (data.IsHighOrder()) {
                auto& lowerFunc = data.GetLowerOrderFunction();
                if (lowerFunc.GetParamNum() == 1 && lowerFunc.GetParamClassUnmasked() == DslData::FunctionData::PARAM_CLASS_ANGLE_BRACKET_COLON) {
                    auto* tp = lowerFunc.GetParam(0);
                    auto ti = ParseParamTypeInfo(*tp);
                    dataType = ti.Type;
                    objTypeId = ti.ObjectTypeId;
                }
            }
            else if (!argLoadInfos.empty()) {
                auto& firstInfo = argLoadInfos.front();
                dataType = firstInfo.Type;
                objTypeId = firstInfo.ObjectTypeId;
            }
            switch (dataType) {
            case Brace::BRACE_DATA_TYPE_BOOL:
                arrayCategory = ARRAY_BOOL;
                break;
            case Brace::BRACE_DATA_TYPE_INT8:
            case Brace::BRACE_DATA_TYPE_UINT8:
            case Brace::BRACE_DATA_TYPE_INT16:
            case Brace::BRACE_DATA_TYPE_UINT16:
            case Brace::BRACE_DATA_TYPE_INT32:
            case Brace::BRACE_DATA_TYPE_UINT32:
            case Brace::BRACE_DATA_TYPE_INT64:
            case Brace::BRACE_DATA_TYPE_UINT64:
                arrayCategory = ARRAY_INT;
                break;
            case Brace::BRACE_DATA_TYPE_FLOAT:
            case Brace::BRACE_DATA_TYPE_DOUBLE:
                arrayCategory = ARRAY_FLOAT;
                break;
            case Brace::BRACE_DATA_TYPE_STRING:
                arrayCategory = ARRAY_STRING;
                break;
            case Brace::BRACE_DATA_TYPE_OBJECT:
                arrayCategory = ARRAY_OBJ;
                break;
            }
            switch (arrayCategory) {
            case ARRAY_BOOL: {
                bool good = true;
                for (auto&& ai : argLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_BOOL && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::swap(m_Args, args);
                    SetArgInfos(argLoadInfos);
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                    resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &ArrayExp::ExecuteBool);
                    return true;
                }
            }break;
            case ARRAY_INT: {
                bool good = true;
                for (auto&& ai : argLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::swap(m_Args, args);
                    SetArgInfos(argLoadInfos);
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                    resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &ArrayExp::ExecuteInt);
                    return true;
                }
            }break;
            case ARRAY_FLOAT: {
                bool good = true;
                for (auto&& ai : argLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_DOUBLE) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::swap(m_Args, args);
                    SetArgInfos(argLoadInfos);
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                    resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &ArrayExp::ExecuteFloat);
                    return true;
                }
            }break;
            case ARRAY_STRING: {
                bool good = true;
                for (auto&& ai : argLoadInfos) {
                    if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::swap(m_Args, args);
                    SetArgInfos(argLoadInfos);
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                    resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &ArrayExp::ExecuteString);
                    return true;
                }
            }break;
            case ARRAY_OBJ: {
                bool good = true;
                for (auto&& ai : argLoadInfos) {
                    if (ai.Type == Brace::BRACE_DATA_TYPE_OBJECT && ai.ObjectTypeId == objTypeId) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::string typeKey = std::string("array<:") + GetObjectTypeName(objTypeId) + ":>";
                    m_ObjectTypeId = g_ObjectInfoMgr.GetObjectTypeId(typeKey);
                    if (m_ObjectTypeId == Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN) {
                        m_ObjectTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(typeKey);
                    }
                    auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(m_ObjectTypeId);
                    if (nullptr == pInfo) {
                        pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(m_ObjectTypeId, BRACE_OBJECT_CATEGORY_OBJ_ARRAY, std::move(typeKey));
                        g_ObjectInfoMgr.SetBraceObjectTypeParams(m_ObjectTypeId, dataType, objTypeId);
                    }
                    if (nullptr != pInfo) {
                        std::swap(m_Args, args);
                        SetArgInfos(argLoadInfos);
                        resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                        resultInfo.ObjectTypeId = m_ObjectTypeId;
                        resultInfo.Name = GenTempVarName();
                        resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                        m_ResultInfo = resultInfo;
                        executor.attach(this, &ArrayExp::ExecuteObject);
                        return true;
                    }
                }
            }break;
            }
            std::stringstream ss;
            ss << "Array syntax error ! array<: bool|int32|float|string|obj :>(v1, v2, ...) line: " << data.GetLine();
            LogError(ss.str());
            return false;
        }
    private:
        void SetArgInfos(std::vector<Brace::OperandLoadtimeInfo> argLoadInfos)
        {
            for (auto&& info : argLoadInfos) {
                m_ArgInfos.push_back(info);
            }
        }
    private:
        int ExecuteBool(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_Args) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            using BoolArrayObj = ArrayT<bool>;
            auto* p = new BoolArrayObj();
            for (auto&& ai : m_ArgInfos) {
                bool v = Brace::VarGetBoolean((ai.IsGlobal ? gvars : lvars), ai.Type, ai.VarIndex);
                p->push_back(v);
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteInt(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_Args) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            using IntArrayObj = ArrayT<int64_t>;
            auto* p = new IntArrayObj();
            for (auto&& ai : m_ArgInfos) {
                int64_t v = Brace::VarGetI64((ai.IsGlobal ? gvars : lvars), ai.Type, ai.VarIndex);
                p->push_back(v);
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteFloat(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_Args) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            using FloatArrayObj = ArrayT<double>;
            auto* p = new FloatArrayObj();
            for (auto&& ai : m_ArgInfos) {
                double v = Brace::VarGetF64((ai.IsGlobal ? gvars : lvars), ai.Type, ai.VarIndex);
                p->push_back(v);
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteString(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_Args) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            using StrArrayObj = ArrayT<std::string>;
            auto* p = new StrArrayObj();
            for (auto&& ai : m_ArgInfos) {
                const std::string& v = Brace::VarGetString((ai.IsGlobal ? gvars : lvars), ai.VarIndex);
                p->push_back(v);
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteObject(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_Args) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            auto* p = new ObjectArray();
            for (auto&& ai : m_ArgInfos) {
                auto& v = Brace::VarGetObject((ai.IsGlobal ? gvars : lvars), ai.VarIndex);
                p->push_back(v);
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    private:
        int m_ObjectTypeId;
        std::vector<Brace::BraceApiExecutor> m_Args;
        std::vector<Brace::OperandRuntimeInfo> m_ArgInfos;
        Brace::OperandRuntimeInfo m_ResultInfo;
    };
    class HashtableExp final : public Brace::AbstractBraceApi
    {
        enum HashtableCategory
        {
            HASHTABLE_UNKNOWN = -1,
            HASHTABLE_STR_STR = 0,
            HASHTABLE_STR_INT,
            HASHTABLE_STR_FLOAT,
            HASHTABLE_STR_BOOL,
            HASHTABLE_STR_OBJ,
            HASHTABLE_INT_STR,
            HASHTABLE_INT_INT,
            HASHTABLE_INT_FLOAT,
            HASHTABLE_INT_BOOL,
            HASHTABLE_INT_OBJ
        };
    public:
        HashtableExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            std::vector<Brace::BraceApiExecutor> argKeys;
            std::vector<Brace::BraceApiExecutor> argVals;
            std::vector<Brace::OperandLoadtimeInfo> argKeyLoadInfos;
            std::vector<Brace::OperandLoadtimeInfo> argValLoadInfos;
            int num = data.GetParamNum();
            for (int ix = 0; ix < num; ++ix) {
                auto* param = data.GetParam(ix);
                if (param->GetSyntaxType() != DslData::ISyntaxComponent::TYPE_FUNCTION || (param->GetId() != "=>" && param->GetId() != ":")) {
                    std::stringstream ss;
                    ss << "Hashtable syntax error ! param must be pairs (k1 => v1, k2 => v2, ...) line: " << data.GetLine();
                    LogError(ss.str());
                    return false;
                }
                auto* funcData = static_cast<DslData::FunctionData*>(param);
                if (funcData->GetParamNum() != 2) {
                    std::stringstream ss;
                    ss << "Hashtable syntax error ! param must be pairs (k1 => v1, k2 => v2, ...) line: " << data.GetLine();
                    LogError(ss.str());
                    return false;
                }
                Brace::OperandLoadtimeInfo argKeyLoadInfo;
                Brace::OperandLoadtimeInfo argValLoadInfo;
                auto p_key = LoadHelper(*funcData->GetParam(0), argKeyLoadInfo);
                auto p_val = LoadHelper(*funcData->GetParam(1), argValLoadInfo);
                argKeys.push_back(std::move(p_key));
                argKeyLoadInfos.push_back(std::move(argKeyLoadInfo));
                argVals.push_back(std::move(p_val));
                argValLoadInfos.push_back(std::move(argValLoadInfo));
            }
            int hashtableCategory = HASHTABLE_UNKNOWN;
            int keyDataType = Brace::BRACE_DATA_TYPE_UNKNOWN;
            int valDataType = Brace::BRACE_DATA_TYPE_UNKNOWN;
            int keyObjTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
            int valObjTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
            if (data.IsHighOrder()) {
                auto& lowerFunc = data.GetLowerOrderFunction();
                if (lowerFunc.GetParamNum() == 2 && lowerFunc.GetParamClassUnmasked() == DslData::FunctionData::PARAM_CLASS_ANGLE_BRACKET_COLON) {
                    const std::string& key = lowerFunc.GetParamId(0);
                    auto* val = lowerFunc.GetParam(1);
                    keyDataType = Brace::GetDataType(key);
                    auto ti = ParseParamTypeInfo(*val);
                    valDataType = ti.Type;
                    valObjTypeId = ti.ObjectTypeId;
                }
            }
            else if (!argKeyLoadInfos.empty() && !argValLoadInfos.empty()) {
                auto& firstKeyInfo = argKeyLoadInfos.front();
                auto& firstValInfo = argValLoadInfos.front();
                keyDataType = firstKeyInfo.Type;
                keyObjTypeId = firstKeyInfo.ObjectTypeId;
                valDataType = firstValInfo.Type;
                valObjTypeId = firstValInfo.ObjectTypeId;
            }
            switch (keyDataType) {
            case Brace::BRACE_DATA_TYPE_STRING:
                switch (valDataType) {
                case Brace::BRACE_DATA_TYPE_BOOL:
                    hashtableCategory = HASHTABLE_STR_BOOL;
                    break;
                case Brace::BRACE_DATA_TYPE_INT8:
                case Brace::BRACE_DATA_TYPE_UINT8:
                case Brace::BRACE_DATA_TYPE_INT16:
                case Brace::BRACE_DATA_TYPE_UINT16:
                case Brace::BRACE_DATA_TYPE_INT32:
                case Brace::BRACE_DATA_TYPE_UINT32:
                case Brace::BRACE_DATA_TYPE_INT64:
                case Brace::BRACE_DATA_TYPE_UINT64:
                    hashtableCategory = HASHTABLE_STR_INT;
                    break;
                case Brace::BRACE_DATA_TYPE_FLOAT:
                case Brace::BRACE_DATA_TYPE_DOUBLE:
                    hashtableCategory = HASHTABLE_STR_FLOAT;
                    break;
                case Brace::BRACE_DATA_TYPE_STRING:
                    hashtableCategory = HASHTABLE_STR_STR;
                    break;
                case Brace::BRACE_DATA_TYPE_OBJECT:
                    hashtableCategory = HASHTABLE_STR_OBJ;
                    break;
                }
                break;
            case Brace::BRACE_DATA_TYPE_INT8:
            case Brace::BRACE_DATA_TYPE_UINT8:
            case Brace::BRACE_DATA_TYPE_INT16:
            case Brace::BRACE_DATA_TYPE_UINT16:
            case Brace::BRACE_DATA_TYPE_INT32:
            case Brace::BRACE_DATA_TYPE_UINT32:
            case Brace::BRACE_DATA_TYPE_INT64:
            case Brace::BRACE_DATA_TYPE_UINT64:
                switch (valDataType) {
                case Brace::BRACE_DATA_TYPE_BOOL:
                    hashtableCategory = HASHTABLE_INT_BOOL;
                    break;
                case Brace::BRACE_DATA_TYPE_INT8:
                case Brace::BRACE_DATA_TYPE_UINT8:
                case Brace::BRACE_DATA_TYPE_INT16:
                case Brace::BRACE_DATA_TYPE_UINT16:
                case Brace::BRACE_DATA_TYPE_INT32:
                case Brace::BRACE_DATA_TYPE_UINT32:
                case Brace::BRACE_DATA_TYPE_INT64:
                case Brace::BRACE_DATA_TYPE_UINT64:
                    hashtableCategory = HASHTABLE_INT_INT;
                    break;
                case Brace::BRACE_DATA_TYPE_FLOAT:
                case Brace::BRACE_DATA_TYPE_DOUBLE:
                    hashtableCategory = HASHTABLE_INT_FLOAT;
                    break;
                case Brace::BRACE_DATA_TYPE_STRING:
                    hashtableCategory = HASHTABLE_INT_STR;
                    break;
                case Brace::BRACE_DATA_TYPE_OBJECT:
                    hashtableCategory = HASHTABLE_INT_OBJ;
                    break;
                }
                break;
            }
            switch (hashtableCategory) {
            case HASHTABLE_INT_BOOL: {
                bool good = true;
                for (auto&& ai : argKeyLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                for (auto&& ai : argValLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_BOOL && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::swap(m_ArgKeys, argKeys);
                    SetArgKeyInfos(argKeyLoadInfos);
                    std::swap(m_ArgVals, argVals);
                    SetArgValInfos(argValLoadInfos);
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                    resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &HashtableExp::ExecuteIntBool);
                    return true;
                }
            }break;
            case HASHTABLE_INT_INT: {
                bool good = true;
                for (auto&& ai : argKeyLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                for (auto&& ai : argValLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::swap(m_ArgKeys, argKeys);
                    SetArgKeyInfos(argKeyLoadInfos);
                    std::swap(m_ArgVals, argVals);
                    SetArgValInfos(argValLoadInfos);
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                    resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &HashtableExp::ExecuteIntInt);
                    return true;
                }
            }break;
            case HASHTABLE_INT_FLOAT: {
                bool good = true;
                for (auto&& ai : argKeyLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                for (auto&& ai : argValLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_DOUBLE) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::swap(m_ArgKeys, argKeys);
                    SetArgKeyInfos(argKeyLoadInfos);
                    std::swap(m_ArgVals, argVals);
                    SetArgValInfos(argValLoadInfos);
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                    resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &HashtableExp::ExecuteIntFloat);
                    return true;
                }
            }break;
            case HASHTABLE_INT_STR: {
                bool good = true;
                for (auto&& ai : argKeyLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                for (auto&& ai : argValLoadInfos) {
                    if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::swap(m_ArgKeys, argKeys);
                    SetArgKeyInfos(argKeyLoadInfos);
                    std::swap(m_ArgVals, argVals);
                    SetArgValInfos(argValLoadInfos);
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                    resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &HashtableExp::ExecuteIntStr);
                    return true;
                }
            }break;
            case HASHTABLE_INT_OBJ: {
                bool good = true;
                for (auto&& ai : argKeyLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                for (auto&& ai : argValLoadInfos) {
                    if (ai.Type == Brace::BRACE_DATA_TYPE_OBJECT && ai.ObjectTypeId == valObjTypeId) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::string tname = GetObjectTypeName(valObjTypeId);
                    std::string typeKey = std::string("hashtable<:int64,") + tname + ":>";
                    int objectTypeId = g_ObjectInfoMgr.GetObjectTypeId(typeKey);
                    if (objectTypeId == Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN) {
                        objectTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(typeKey);
                        g_ObjectInfoMgr.AddBraceObjectAlias(objectTypeId, "hashtable<:int8," + tname + ":>");
                        g_ObjectInfoMgr.AddBraceObjectAlias(objectTypeId, "hashtable<:int16," + tname + ":>");
                        g_ObjectInfoMgr.AddBraceObjectAlias(objectTypeId, "hashtable<:int32," + tname + ":>");
                        g_ObjectInfoMgr.AddBraceObjectAlias(objectTypeId, "hashtable<:uint8," + tname + ":>");
                        g_ObjectInfoMgr.AddBraceObjectAlias(objectTypeId, "hashtable<:uint16," + tname + ":>");
                        g_ObjectInfoMgr.AddBraceObjectAlias(objectTypeId, "hashtable<:uint32," + tname + ":>");
                        g_ObjectInfoMgr.AddBraceObjectAlias(objectTypeId, "hashtable<:uint64," + tname + ":>");
                    }
                    auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objectTypeId);
                    if (nullptr == pInfo) {
                        pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(objectTypeId, BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE, std::move(typeKey));
                        g_ObjectInfoMgr.SetBraceObjectTypeParams(objectTypeId, keyDataType, keyObjTypeId, valDataType, valObjTypeId);
                    }
                    if (nullptr != pInfo) {
                        std::swap(m_ArgKeys, argKeys);
                        SetArgKeyInfos(argKeyLoadInfos);
                        std::swap(m_ArgVals, argVals);
                        SetArgValInfos(argValLoadInfos);
                        resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                        resultInfo.ObjectTypeId = objectTypeId;
                        resultInfo.Name = GenTempVarName();
                        resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                        m_ResultInfo = resultInfo;
                        executor.attach(this, &HashtableExp::ExecuteIntObj);
                        return true;
                    }
                }
            }break;
            case HASHTABLE_STR_BOOL: {
                bool good = true;
                for (auto&& ai : argKeyLoadInfos) {
                    if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                for (auto&& ai : argValLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_BOOL && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::swap(m_ArgKeys, argKeys);
                    SetArgKeyInfos(argKeyLoadInfos);
                    std::swap(m_ArgVals, argVals);
                    SetArgValInfos(argValLoadInfos);
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                    resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &HashtableExp::ExecuteStrBool);
                    return true;
                }
            }break;
            case HASHTABLE_STR_INT: {
                bool good = true;
                for (auto&& ai : argKeyLoadInfos) {
                    if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                for (auto&& ai : argValLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::swap(m_ArgKeys, argKeys);
                    SetArgKeyInfos(argKeyLoadInfos);
                    std::swap(m_ArgVals, argVals);
                    SetArgValInfos(argValLoadInfos);
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                    resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &HashtableExp::ExecuteStrInt);
                    return true;
                }
            }break;
            case HASHTABLE_STR_FLOAT: {
                bool good = true;
                for (auto&& ai : argKeyLoadInfos) {
                    if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                for (auto&& ai : argValLoadInfos) {
                    if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_DOUBLE) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::swap(m_ArgKeys, argKeys);
                    SetArgKeyInfos(argKeyLoadInfos);
                    std::swap(m_ArgVals, argVals);
                    SetArgValInfos(argValLoadInfos);
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                    resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &HashtableExp::ExecuteStrFloat);
                    return true;
                }
            }break;
            case HASHTABLE_STR_STR: {
                bool good = true;
                for (auto&& ai : argKeyLoadInfos) {
                    if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                for (auto&& ai : argValLoadInfos) {
                    if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::swap(m_ArgKeys, argKeys);
                    SetArgKeyInfos(argKeyLoadInfos);
                    std::swap(m_ArgVals, argVals);
                    SetArgValInfos(argValLoadInfos);
                    resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                    resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE;
                    resultInfo.Name = GenTempVarName();
                    resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                    m_ResultInfo = resultInfo;
                    executor.attach(this, &HashtableExp::ExecuteStrStr);
                    return true;
                }
            }break;
            case HASHTABLE_STR_OBJ: {
                bool good = true;
                for (auto&& ai : argKeyLoadInfos) {
                    if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                for (auto&& ai : argValLoadInfos) {
                    if (ai.Type == Brace::BRACE_DATA_TYPE_OBJECT && ai.ObjectTypeId == valObjTypeId) {
                    }
                    else {
                        good = false;
                        break;
                    }
                }
                if (good) {
                    std::string typeKey = std::string("hashtable<:string,") + GetObjectTypeName(valObjTypeId) + ":>";
                    int objectTypeId = g_ObjectInfoMgr.GetObjectTypeId(typeKey);
                    if (objectTypeId == Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN) {
                        objectTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(typeKey);
                    }
                    auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objectTypeId);
                    if (nullptr == pInfo) {
                        pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(objectTypeId, BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE, std::move(typeKey));
                        g_ObjectInfoMgr.SetBraceObjectTypeParams(objectTypeId, keyDataType, keyObjTypeId, valDataType, valObjTypeId);
                    }
                    if (nullptr != pInfo) {
                        std::swap(m_ArgKeys, argKeys);
                        SetArgKeyInfos(argKeyLoadInfos);
                        std::swap(m_ArgVals, argVals);
                        SetArgValInfos(argValLoadInfos);
                        resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
                        resultInfo.ObjectTypeId = objectTypeId;
                        resultInfo.Name = GenTempVarName();
                        resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
                        m_ResultInfo = resultInfo;
                        executor.attach(this, &HashtableExp::ExecuteStrObj);
                        return true;
                    }
                }
            }break;
            }
            std::stringstream ss;
            ss << "Hashtable syntax error ! hashtable<: int32|string, bool|int32|float|string|obj :>(k1 => v1, k2 => v2, ...) line: " << data.GetLine();
            LogError(ss.str());
            return false;
        }
    private:
        void SetArgKeyInfos(std::vector<Brace::OperandLoadtimeInfo> argKeyLoadInfos)
        {
            for (auto&& info : argKeyLoadInfos) {
                m_ArgKeyInfos.push_back(info);
            }
        }
        void SetArgValInfos(std::vector<Brace::OperandLoadtimeInfo> argValLoadInfos)
        {
            for (auto&& info : argValLoadInfos) {
                m_ArgValInfos.push_back(info);
            }
        }
    private:
        int ExecuteIntStr(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_ArgKeys) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            for (auto&& arg : m_ArgVals) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            using HashtableObj = HashtableT<int64_t, std::string>;
            auto* p = new HashtableObj();
            for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
                auto& key = m_ArgKeyInfos[ix];
                auto& val = m_ArgValInfos[ix];
                int64_t k = Brace::VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
                std::string v = Brace::VarGetStr((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                p->insert(std::make_pair(k, std::move(v)));
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteIntInt(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_ArgKeys) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            for (auto&& arg : m_ArgVals) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            using HashtableObj = HashtableT<int64_t, int64_t>;
            auto* p = new HashtableObj();
            for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
                auto& key = m_ArgKeyInfos[ix];
                auto& val = m_ArgValInfos[ix];
                int64_t k = Brace::VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
                int64_t v = Brace::VarGetI64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                p->insert(std::make_pair(k, v));
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteIntFloat(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_ArgKeys) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            for (auto&& arg : m_ArgVals) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            using HashtableObj = HashtableT<int64_t, double>;
            auto* p = new HashtableObj();
            for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
                auto& key = m_ArgKeyInfos[ix];
                auto& val = m_ArgValInfos[ix];
                int64_t k = Brace::VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
                double v = Brace::VarGetF64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                p->insert(std::make_pair(k, v));
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteIntBool(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_ArgKeys) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            for (auto&& arg : m_ArgVals) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            using HashtableObj = HashtableT<int64_t, bool>;
            auto* p = new HashtableObj();
            for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
                auto& key = m_ArgKeyInfos[ix];
                auto& val = m_ArgValInfos[ix];
                int64_t k = Brace::VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
                bool v = Brace::VarGetBoolean((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                p->insert(std::make_pair(k, v));
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteIntObj(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_ArgKeys) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            for (auto&& arg : m_ArgVals) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            auto* p = new IntObjHashtable();
            for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
                auto& key = m_ArgKeyInfos[ix];
                auto& val = m_ArgValInfos[ix];
                int64_t k = Brace::VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
                auto v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
                p->insert(std::make_pair(k, std::move(v)));
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteStrStr(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_ArgKeys) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            for (auto&& arg : m_ArgVals) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            using HashtableObj = HashtableT<std::string, std::string>;
            auto* p = new HashtableObj();
            for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
                auto& key = m_ArgKeyInfos[ix];
                auto& val = m_ArgValInfos[ix];
                std::string k = Brace::VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
                std::string v = Brace::VarGetStr((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                p->insert(std::make_pair(std::move(k), std::move(v)));
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteStrInt(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_ArgKeys) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            for (auto&& arg : m_ArgVals) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            using HashtableObj = HashtableT<std::string, int64_t>;
            auto* p = new HashtableObj();
            for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
                auto& key = m_ArgKeyInfos[ix];
                auto& val = m_ArgValInfos[ix];
                std::string k = Brace::VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
                int64_t v = Brace::VarGetI64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                p->insert(std::make_pair(std::move(k), v));
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteStrFloat(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_ArgKeys) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            for (auto&& arg : m_ArgVals) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            using HashtableObj = HashtableT<std::string, double>;
            auto* p = new HashtableObj();
            for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
                auto& key = m_ArgKeyInfos[ix];
                auto& val = m_ArgValInfos[ix];
                std::string k = Brace::VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
                double v = Brace::VarGetF64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                p->insert(std::make_pair(std::move(k), v));
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteStrBool(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_ArgKeys) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            for (auto&& arg : m_ArgVals) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            using HashtableObj = HashtableT<std::string, bool>;
            auto* p = new HashtableObj();
            for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
                auto& key = m_ArgKeyInfos[ix];
                auto& val = m_ArgValInfos[ix];
                std::string k = Brace::VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
                bool v = Brace::VarGetBoolean((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
                p->insert(std::make_pair(std::move(k), v));
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
        int ExecuteStrObj(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
        {
            for (auto&& arg : m_ArgKeys) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            for (auto&& arg : m_ArgVals) {
                if (!arg.isNull())
                    arg(gvars, lvars);
            }
            auto* p = new StrObjHashtable();
            for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
                auto& key = m_ArgKeyInfos[ix];
                auto& val = m_ArgValInfos[ix];
                std::string k = Brace::VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
                auto v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
                p->insert(std::make_pair(std::move(k), std::move(v)));
            }
            Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<void>(p));
            return Brace::BRACE_FLOW_CONTROL_NORMAL;
        }
    private:
        std::vector<Brace::BraceApiExecutor> m_ArgKeys;
        std::vector<Brace::OperandRuntimeInfo> m_ArgKeyInfos;
        std::vector<Brace::BraceApiExecutor> m_ArgVals;
        std::vector<Brace::OperandRuntimeInfo> m_ArgValInfos;
        Brace::OperandRuntimeInfo m_ResultInfo;
    };
    class LoopListExp final : public Brace::AbstractBraceApi
    {
    public:
        LoopListExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ApiProvider()
        {
        }
    protected:
        virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& funcData, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            if (funcData.IsHighOrder()) {
                bool ret = false;
                auto* p = funcData.GetLowerOrderFunction().GetParam(0);
                Brace::OperandLoadtimeInfo loadInfo;
                auto list = LoadHelper(*p, loadInfo);
                auto& listInfo = loadInfo;
                PushBlock();
                BraceObjectInfo* pInfo = nullptr;
                AbstractLoopListApiProvider* pProvider = nullptr;
                if (listInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
                    pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(listInfo.ObjectTypeId);
                    if (nullptr != pInfo) {
                        switch (pInfo->ObjectCategory) {
                        case BRACE_OBJECT_CATEGORY_UOBJECT:
                        case BRACE_OBJECT_CATEGORY_ACTOR:
                        default:
                            pProvider = new ArrayHashtableLoopListProvider(GetInterpreter());
                            break;
                        }
                    }
                }
                else if (listInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
                    pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
                    if (nullptr != pInfo) {
                        pProvider = new StringLoopListProvider(GetInterpreter());
                    }
                }
                if (pProvider) {
                    m_ApiProvider.reset(pProvider);
                    if (pProvider->TypeInference(func, funcData, *pInfo, listInfo, executor)) {
                        std::vector<Brace::BraceApiExecutor> statements{};
                        for (int ix = 0; ix < funcData.GetParamNum(); ++ix) {
                            Brace::OperandLoadtimeInfo argLoadInfo;
                            auto statement = LoadHelper(*funcData.GetParam(ix), argLoadInfo);
                            if (!statement.isNull())
                                statements.push_back(std::move(statement));
                        }
                        auto& objVars = CurBlockObjVars();
                        pProvider->StoreRuntimeInfo(std::move(listInfo), std::move(list), std::move(statements), objVars);
                        ret = true;
                    }
                }
                PopBlock();
                if (ret)
                    return true;
            }
            //error
            std::stringstream ss;
            ss << "BraceScript error, " << funcData.GetId() << " line " << funcData.GetLine();
            LogError(ss.str());
            return false;
        }
        virtual bool LoadStatement(const Brace::FuncInfo& func, const DslData::StatementData& statementData, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
        {
            //looplist(exp) func(args);
            if (statementData.GetFunctionNum() == 2) {
                auto* first = statementData.GetFirst()->AsFunction();
                //const std::string& firstId = first->GetId();
                if (!first->HaveStatement() && !first->HaveExternScript()) {
                    auto* second = statementData.GetSecond();
                    auto* secondVal = second->AsValue();
                    auto* secondFunc = second->AsFunction();
                    if (nullptr != secondVal || (nullptr != secondFunc && secondFunc->HaveId() && !secondFunc->HaveStatement() && !secondFunc->HaveExternScript())) {
                        if (first->GetParamNum() > 0) {
                            bool ret = false;
                            auto* exp = first->GetParam(0);
                            Brace::OperandLoadtimeInfo loadInfo;
                            auto list = LoadHelper(*exp, loadInfo);
                            auto& listInfo = loadInfo;
                            PushBlock();
                            if (listInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
                                auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(listInfo.ObjectTypeId);
                                if (nullptr != pInfo) {
                                    AbstractLoopListApiProvider* pProvider = nullptr;
                                    switch (pInfo->ObjectCategory) {
                                    case BRACE_OBJECT_CATEGORY_UOBJECT:
                                    case BRACE_OBJECT_CATEGORY_ACTOR:
                                    default:
                                        pProvider = new ArrayHashtableLoopListProvider(GetInterpreter());
                                        break;
                                    }
                                    if (pProvider) {
                                        m_ApiProvider.reset(pProvider);
                                        if (pProvider->TypeInference(func, statementData, *pInfo, listInfo, executor)) {
                                            Brace::OperandLoadtimeInfo argLoadInfo;
                                            std::vector<Brace::BraceApiExecutor> statements{};
                                            auto statement = LoadHelper(*second, argLoadInfo);
                                            if (!statement.isNull())
                                                statements.push_back(std::move(statement));
                                            auto& objVars = CurBlockObjVars();
                                            pProvider->StoreRuntimeInfo(std::move(listInfo), std::move(list), std::move(statements), objVars);
                                            ret = true;
                                        }
                                    }
                                }
                            }
                            PopBlock();
                            if (ret)
                                return true;
                        }
                    }
                }
            }
            //error
            std::stringstream ss;
            ss << "BraceScript error, " << statementData.GetId() << " line " << statementData.GetLine();
            LogError(ss.str());
            return false;
        }
    private:
        std::unique_ptr<AbstractLoopListApiProvider> m_ApiProvider;
    };
}
/*
*   ========== InitGlobalBraceObjectInfo ==========
* 

	//add fixed map, obj table id <-> obj category
        g_ObjectInfoMgr.AddBraceObjectInfo(Brace::PREDEFINED_BRACE_OBJECT_TYPE_ANY, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "any");  //fake obj info for any
        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "string");  //fake obj info for string 
        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT, BRACE_OBJECT_CATEGORY_UOBJECT, "uobject");

        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "array<:bool:>");
        g_ObjectInfoMgr.SetBraceObjectTypeParams(CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY, Brace::BRACE_DATA_TYPE_BOOL, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);

        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "array<:int64:>");
        g_ObjectInfoMgr.SetBraceObjectTypeParams(CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY, Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);

        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "array<:double:>");
        g_ObjectInfoMgr.SetBraceObjectTypeParams(CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY, Brace::BRACE_DATA_TYPE_DOUBLE, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);

        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "array<:string:>");
        g_ObjectInfoMgr.SetBraceObjectTypeParams(CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY, Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);

        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:int64,bool:>");
        g_ObjectInfoMgr.SetBraceObjectTypeParams(CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE, Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_BOOL, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);

        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:int64,int64:>");
        g_ObjectInfoMgr.SetBraceObjectTypeParams(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);

        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:int64,double:>");
        g_ObjectInfoMgr.SetBraceObjectTypeParams(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_DOUBLE, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);

        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:int64,string:>");
        g_ObjectInfoMgr.SetBraceObjectTypeParams(CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE, Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);

        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:string,bool:>");
        g_ObjectInfoMgr.SetBraceObjectTypeParams(CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE, Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_BOOL, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);

        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:string,int64:>");
        g_ObjectInfoMgr.SetBraceObjectTypeParams(CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE, Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);

        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:string,double:>");
        g_ObjectInfoMgr.SetBraceObjectTypeParams(CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE, Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_DOUBLE, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);

        g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:string,string:>");
        g_ObjectInfoMgr.SetBraceObjectTypeParams(CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE, Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);

        //----------------
        {
            std::string uobjArrayKey = "array<:uobject:>";
            int objTypeId = g_ObjectInfoMgr.GetObjectTypeId(uobjArrayKey);
            if (Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN == objTypeId) {
                objTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(uobjArrayKey);
            }
            auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
            if (nullptr == pInfo) {
                pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(objTypeId, BRACE_OBJECT_CATEGORY_OBJ_ARRAY, std::move(uobjArrayKey));
                g_ObjectInfoMgr.SetBraceObjectTypeParams(objTypeId, Brace::BRACE_DATA_TYPE_OBJECT, CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT);
            }
        }
        //----------------
        {
            std::string anyArrayKey = "array<:any:>";
            int objTypeId = g_ObjectInfoMgr.GetObjectTypeId(anyArrayKey);
            if (Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN == objTypeId) {
                objTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(anyArrayKey);
            }
            auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
            if (nullptr == pInfo) {
                pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(objTypeId, BRACE_OBJECT_CATEGORY_OBJ_ARRAY, std::move(anyArrayKey));
                g_ObjectInfoMgr.SetBraceObjectTypeParams(objTypeId, Brace::BRACE_DATA_TYPE_OBJECT, Brace::PREDEFINED_BRACE_OBJECT_TYPE_ANY);
            }
        }
        //----------------
        {
            std::string strObjHashKey = "hashtable<:string,uobject:>";
            int objTypeId = g_ObjectInfoMgr.GetObjectTypeId(strObjHashKey);
            if (Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN == objTypeId) {
                objTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(strObjHashKey);
            }
            auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
            if (nullptr == pInfo) {
                pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(objTypeId, BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE, std::move(strObjHashKey));
                g_ObjectInfoMgr.SetBraceObjectTypeParams(objTypeId, Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_OBJECT, CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT);
            }
        }
        //----------------
        {
            std::string intObjHashKey = "hashtable<:int64,uobject:>";
            int objTypeId = g_ObjectInfoMgr.GetObjectTypeId(intObjHashKey);
            if (Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN == objTypeId) {
                objTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(intObjHashKey);
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:int8,uobject:>");
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:int16,uobject:>");
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:int32,uobject:>");
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:uint8,uobject:>");
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:uint16,uobject:>");
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:uint32,uobject:>");
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:uint64,uobject:>");
            }
            auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
            if (nullptr == pInfo) {
                pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(objTypeId, BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE, std::move(intObjHashKey));
                g_ObjectInfoMgr.SetBraceObjectTypeParams(objTypeId, Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_OBJECT, CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT);
            }
        }
        //----------------
        {
            std::string strAnyHashKey = "hashtable<:string,any:>";
            int objTypeId = g_ObjectInfoMgr.GetObjectTypeId(strAnyHashKey);
            if (Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN == objTypeId) {
                objTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(strAnyHashKey);
            }
            auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
            if (nullptr == pInfo) {
                pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(objTypeId, BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE, std::move(strAnyHashKey));
                g_ObjectInfoMgr.SetBraceObjectTypeParams(objTypeId, Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_OBJECT, Brace::PREDEFINED_BRACE_OBJECT_TYPE_ANY);
            }
        }
        //----------------
        {
            std::string intAnyHashKey = "hashtable<:int64,any:>";
            int objTypeId = g_ObjectInfoMgr.GetObjectTypeId(intAnyHashKey);
            if (Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN == objTypeId) {
                objTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(intAnyHashKey);
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:int8,any:>");
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:int16,any:>");
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:int32,any:>");
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:uint8,any:>");
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:uint16,any:>");
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:uint32,any:>");
                g_ObjectInfoMgr.AddBraceObjectAlias(objTypeId, "hashtable<:uint64,any:>");
            }
            auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
            if (nullptr == pInfo) {
                pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(objTypeId, BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE, std::move(intAnyHashKey));
                g_ObjectInfoMgr.SetBraceObjectTypeParams(objTypeId, Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, Brace::BRACE_DATA_TYPE_OBJECT, Brace::PREDEFINED_BRACE_OBJECT_TYPE_ANY);
            }
        }
        //----------------
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY, "array<:int8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY, "array<:int16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY, "array<:int32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY, "array<:uint8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY, "array<:uint16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY, "array<:uint32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY, "array<:uint64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY, "array<:float:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE, "hashtable<:int8,bool:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int8,int64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:int8,double:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE, "hashtable<:int8,string:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE, "hashtable<:int16,bool:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int16,int64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:int16,double:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE, "hashtable<:int16,string:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE, "hashtable<:int32,bool:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int32,int64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:int32,double:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE, "hashtable<:int32,string:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE, "hashtable<:uint8,bool:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint8,int64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:uint8,double:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE, "hashtable<:uint8,string:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE, "hashtable<:uint16,bool:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint16,int64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:uint16,double:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE, "hashtable<:uint16,string:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE, "hashtable<:uint32,bool:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint32,int64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:uint32,double:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE, "hashtable<:uint32,string:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE, "hashtable<:uint64,bool:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint64,int64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:uint64,double:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE, "hashtable<:uint64,string:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE, "hashtable<:string,int8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE, "hashtable<:string,int16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE, "hashtable<:string,int32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE, "hashtable<:string,uint8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE, "hashtable<:string,uint16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE, "hashtable<:string,uint32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE, "hashtable<:string,uint64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE, "hashtable<:string,float:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:int8,float:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:int16,float:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:int32,float:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:int64,float:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:uint8,float:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:uint16,float:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:uint32,float:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, "hashtable<:uint64,float:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int8,int8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int16,int8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int32,int8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int64,int8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint8,int8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint16,int8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint32,int8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint64,int8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int8,int16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int16,int16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int32,int16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int64,int16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint8,int16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint16,int16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint32,int16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint64,int16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int8,int32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int16,int32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int32,int32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int64,int32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint8,int32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint16,int32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint32,int32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint64,int32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int8,uint8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int16,uint8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int32,uint8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int64,uint8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint8,uint8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint16,uint8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint32,uint8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint64,uint8:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int8,uint16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int16,uint16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int32,uint16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int64,uint16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint8,uint16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint16,uint16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint32,uint16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint64,uint16:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int8,uint32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int16,uint32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int32,uint32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int64,uint32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint8,uint32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint16,uint32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint32,uint32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint64,uint32:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int8,uint64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int16,uint64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int32,uint64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:int64,uint64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint8,uint64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint16,uint64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint32,uint64:>");
        g_ObjectInfoMgr.AddBraceObjectAlias(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, "hashtable<:uint64,uint64:>");
	
	// ========== InitBraceScript ==========
	// ========== in BraceScript init code, some callbacks must be implemented. ==========
	m_pBraceScript = new Brace::BraceScript();
	m_pBraceScript->OnInfo = [](auto& str) { printf("[brace info]:%s", str.c_str()); };
	m_pBraceScript->OnWarn = [](auto& str) { printf("[brace warn]:%s", str.c_str()); };
	m_pBraceScript->OnError = [](auto& str) { printf("[brace error]:%s", str.c_str()); };

        m_pBraceScript->OnGetObjectTypeId = [](const DslData::ISyntaxComponent& syntax, const Brace::LoadTypeInfoDelegation& doLoadTypeInfo) {
            int objTypeId;
            g_ObjectInfoMgr.TryGetOrAddBraceObjectInfo(syntax, doLoadTypeInfo, objTypeId);
            return objTypeId;
        };
	m_pBraceScript->OnGetObjectTypeName = [](int objTypeId) {
		auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
		if (nullptr != pInfo)
			return pInfo->TypeName.c_str();
		return "unknown";
	};
	m_pBraceScript->OnObjectAssignCheck = [](int destObjTypeId, int srcObjTypeId) {
		if (destObjTypeId == srcObjTypeId)
			return true;
		return false;
	};

	/// missing language features
        m_pBraceScript->RegisterApi("membercall", "object member call", new Brace::BraceApiFactory<MemberCallExp>());
        m_pBraceScript->RegisterApi("memberset", "object property set", new Brace::BraceApiFactory<MemberSetExp>());
        m_pBraceScript->RegisterApi("memberget", "object property get", new Brace::BraceApiFactory<MemberGetExp>());
        m_pBraceScript->RegisterApi("collectioncall", "collection member call", new Brace::BraceApiFactory<CollectionCallExp>());
        m_pBraceScript->RegisterApi("collectionset", "collection property set", new Brace::BraceApiFactory<CollectionSetExp>());
        m_pBraceScript->RegisterApi("collectionget", "collection property get", new Brace::BraceApiFactory<CollectionGetExp>());
        m_pBraceScript->RegisterApi("linq", "objs.where(args) or objs.orderby(args) or objs.orderbydesc(args) or objs.top(args) or linq(objs,method_str,arg1,arg2,...) statement", new Brace::BraceApiFactory<LinqExp>());
        m_pBraceScript->RegisterApi("select", "select(fields)top(10)from(objlist)where(exp)oderby(exps)groupby(exps)having(exp){statements;} statement", new Brace::BraceApiFactory<SelectExp>());
        m_pBraceScript->RegisterApi("lambda", "lambda expression, (args) => {...} or (args)int => {...} or [...](args) => {...} or [...](args)int => {...}", new Brace::BraceApiFactory<LambdaExp>());
        m_pBraceScript->RegisterApi("array", "[v1,v2,...] or array(v1,v2,...) or array<:type:>(v1,v2,...) object", new Brace::BraceApiFactory<ArrayExp>());
        m_pBraceScript->RegisterApi("hashtable", "{k1=>v1,k2=>v2,...} or {k1:v1,k2:v2,...} or hashtable(k1=>v1,k2=>v2,...) or hashtable(k1:v1,k2:v2,...) or hashtable<:key_type,val_type:>(k1=>v1,k2=>v2,...) or hashtable<:key_type,val_type:>(k1:v1,k2:v2,...) object", new Brace::BraceApiFactory<HashtableExp>());
        m_pBraceScript->RegisterApi("looplist", "looplist statement", new Brace::BraceApiFactory<LoopListExp>());
        m_pBraceScript->RegisterApi("cast", "cast(exp,type) api", new Brace::BraceApiFactory<CastExp>());
        m_pBraceScript->RegisterApi("typetag", "typetag(type) or typetag(exp) api", new Brace::BraceApiFactory<TypeTagExp>());
        m_pBraceScript->RegisterApi("typeid", "typeid(type) or typeid(exp) api", new Brace::BraceApiFactory<TypeIdExp>());
        m_pBraceScript->RegisterApi("objtypeid", "objtypeid(type) or objtypeid(exp) api", new Brace::BraceApiFactory<ObjTypeIdExp>());
        m_pBraceScript->RegisterApi("getobjtypename", "getobjtypename(objtypeid) api", new Brace::BraceApiFactory<GetObjTypeNameExp>());
        m_pBraceScript->RegisterApi("getobjcategory", "getobjcategory(objtypeid) api", new Brace::BraceApiFactory<GetObjCategoryExp>());
        m_pBraceScript->RegisterApi("gettypeparamcount", "gettypeparamcount(objtypeid) api", new Brace::BraceApiFactory<GetTypeParamCountExp>());
        m_pBraceScript->RegisterApi("gettypeparamtype", "gettypeparamtype(objtypeid,index) api", new Brace::BraceApiFactory<GetTypeParamTypeExp>());
        m_pBraceScript->RegisterApi("gettypeparamobjtypeid", "gettypeparamobjtypeid(objtypeid,index) api", new Brace::BraceApiFactory<GetTypeParamObjTypeIdExp>());
        m_pBraceScript->RegisterApi("swap", "swap(var1,var2) api", new Brace::BraceApiFactory<SwapExp>());
        m_pBraceScript->RegisterApi("struct", "struct(name){a:int32;b:int32;...}, define struct", new Brace::BraceApiFactory<StructExp>());
        m_pBraceScript->RegisterApi("newstruct", "newstruct(struct_type) api", new Brace::BraceApiFactory<NewStructExp>());
        m_pBraceScript->RegisterApi("reinterpretas", "reinterpret_cast(uint,struct_type) api", new Brace::BraceApiFactory<ReInterpretAsExp>());

*/